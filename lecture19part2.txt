the Clauses there could be anything whereas in KSAT you're given your as a promise that your input is always a kcnf formula so your inputs are sort of more restricted in case act than they are inside so just by virtue of that KSAT is at most as hard as sat because there's this kind of very simple reduction to sat you just keep the input instance the same and if the KC and a formula is satisfiable you could just feed it into the SAT algorithm and it will tell you the right answer okay so KSAT easily reduces to sat it's a special case of sat right so we want to know now when are these special cases already NP hard okay and it will turn out that there's a very nice kind of dichotomy it will turn out that whenever K is greater than or equal to three yeah three side four side five side all of these things are NP complete and two side is kind of special it turns out to be in polynomial time ok so when K is greater than equal to three this problem turns out to be NP complete and two circles and this is sort of the main content of this lecture so we're going to see why each of these things is true just to get an understanding of the sad problem and also three sat all right so so we showed already the last time that sat is NP hard and we are now going to argue that free side is NP complete and just to say that just like KSAT was a special case of sat three sat is a special case of foresight right so a three CNF formula is also a 4C and a formula a 4C in a formula is also a five CNF formula and so on so if I show that three side is NP complete that also means that foresight is NP complete and 5 star is NP complete and so on okay so I'm going to only argue about three sat but it automatically implies that uh four sat five sat Etc and so let's see if we can do this before the break so I'm going to try to argue to you that three sat is MP complete and I want to give you two arguments for this they're both reasonably simple I think so a first argument actually just goes back to our proof that sat is NP complete precisely the fact that sat is NP hard so how did we show that sato's NP hide first we show that circuit such as NP hired right we did this yeah and let's skip that right I don't want to kind of rehash the proof of that so let's assume that we know that circuit MP hard already and then we reduce circuit sat to three side yeah and if you vaguely remember how we did this so this this transformation actually has a name it's called the Satan transformation so the way we did this is that we start with the circuit that looks something like this and we produce a SAT a CNF Formula F right and it's going to be on the variables of the circuit and three new variables okay in this case I guess it's three new variables but in general you would have variables corresponding to the gates of the original circuit so I have maybe one new variable for this gate one variable for this gate one variable for this gate so on okay and now you add here so you sort of you add Boolean functions that sort of check that y1 follows the computation of the circuit in this way right so y1 is supposed to be the r of X1 and X2 so you sort of add a 3C and a formula that checks this okay so I'm just saying this but this is really a collection of Clauses that enforce the fact that y1 is the r of x 1 x 2. okay and then you add another one where you say that Y2 is the r of X2 and X3 and Y 3 is the r of y1 and Y two not the or sorry the and and finally because it's supposed to be a satisfying assignment you check that Y3 is outputs one okay so so you you'll see in a formula essentially checks a collection of Boolean constraints and each of these Boolean constraints say that the values to these y variables follow the computation of the circuit okay so this is sort of the vague outline uh and this is all you need to understand for this reduction so so there's this thing so we write down these constraints okay and the important thing to notice about these constraints is that these are not really cnfs right these are some weird Boolean constraints but each of these Boolean constraints depends on only three variables at a time okay and we saw that any Boolean function that can be that depends on a three variables at a time can be written as a three C and F right so you take any Boolean function it depends on three variables you write down its true table right and we wrote in in terms of its two tables we looked at all the rows that output 0 and we wrote down a clause per row and we took the conjunction of all these Clauses and that's how we constructed a three CNF so if you just go back to that conversion of this thing to a C and F Formula you will see that you get actually a three CNF formula okay so each of these things actually becomes a three CNF formula okay so we didn't point it out at the time at the time we simply said there's a CNF formula with almost eight Clauses but if you go back and look at the formula that you construct you actually get a three CNF formula a formula where you have where every Clause has width at most three so as a result if you just go back and stare at a reduction it turns out that you're actually giving a reduction from circuit sat to three sack okay it's not circuit cyto General side it's it is a reduction from circuit side to three side okay and this just requires you to go back and look at it all right so in particular now we know that circuit set is NP hard and we this reduction actually gives a reduction from circuit side to three sack so therefore three sat is also NP hard and of course three sat is in NP it's a special case of sat it's an NP and therefore three sat is NP completed does that make sense it's an argument I mean even if you don't recall all the details of the previous proof but the idea is that you just go back and stare at it and the point is that these constraints all depend on just three things at a time and therefore you get three seconds okay so that's one argument that shows the three satis NP complete but I also want to give you a different argument because it has its own uses so I'll give you a different argument that reduces sat to three side okay so let's assume for now that we didn't we don't want to use this so let's forget about it let's not worry about the details of Cook's theorem and let's assume that we only know that sat is NP hard okay so sat is again it's a c it's a c in a formula but there's no bound on the width of the Clauses that appear in the formula so there could be anything right and now what I want to do is I'm going to give a reduction r from sac to 3 sec okay I want to give a reduction from our side to three side so how am I going to do this so what's the reduction got to do so it starts with some formula okay this is just a CNF formula there's no bound at the widths of the Clauses there could be anything it could be really big the reduction of course doesn't know if this formula is satisfiable or unsatisfiable but nevertheless what it does is that it Maps it to a new three CNF formula the reduction Maps the CNF formula to a three CNF formula such that f is satisfiable so you want the reduction to have the property that f is satisfiable if and only if F Prime is satisfiable so if Prime is in three side right so this is the kind of reduction you want to build so how would we build such a reduction so let's start with a very very simple case Okay so so this is a CNF formula so it's a conjunction of Clauses so you have one Clause C1 C2 you know a bunch of clauses I don't know maybe M clauses and let's assume just for the beginning yeah yeah that almost all of these Clauses have width at most three let us say all the Clause except the first Clause have width atmosphere they have at most three variables each except for the first clause which is a problem OK so let's just write down the first Clause separately maybe it's something like this so you have some Clause here which is not a clause of width three so now you want to come up with a three c and a formula which sort of I know it has to do something to this Clause right this Clause cannot be left as is so we have to break this Clause somehow but still we have to preserve satisfiability so how are you going to do this so there's sort of one obvious way to do it which is just okay there's this Clause of length four let's just break it into two pieces of you know width at most three each so I could say you know write this as x one or not x two x three or X4 or you know I take the end of these two and then I keep the other Clauses the same because I'm assuming that all the other Clauses have width at most three so I could do this all right so this is definitely sort of at least to me this is the first thing that comes to mind you have one big Clause just break into two pieces yeah unfortunately there's a problem with this reduction because it's not really a reduction so you could imagine uh that F was a satisfiable formula right so f is a satisfiable Formula so let's say it has some sort of satisfying assignment right x one to X N you have some satisfying assignment yeah S A stands for satisfying assignment sorry S A satisfying seven so you have some satisfying assignment for f right from here you would like it to be the case that if Prime is also satisfiable that it has a satisfying assignment right unfortunately it's not clear how to come up with a satisfying assignment for f Prime right because what's the most obvious thing to try well F and F Prime have the same set of variables yeah so maybe take the same assignment right maybe it works right it seems the most obvious thing to try and in fact the most reasonable thing to try in this situation but that doesn't seem to work right because if x one to X N is a satisfying assignment for f that means it must set at least one of these literals to True right must set at least one of these letters to prove but maybe in the worst case it just sets one of them to True right so maybe it sets X1 to 0 x 3 to 0 x 4 to 0 and maybe it satisfies this one so it sets X2 to 0 so that's here and that satisfies not x two and therefore it's a satisfying assignment so you could have a satisfying assignment that looks like this here and that would translate on this side to a satisfying assignment for this Clause right because again not x 2 is set to 1 that's fine but it wouldn't translate to satisfying assignment for this Clause right so that's not great because both X3 and X4 are set to zero it's not satisfying so a very natural idea but it sort of breaks down because it's not really a proper reduction okay so now to get a reduction from here we just have to modify tweak this idea a little bit and that little bit is a little bit of a trick but it should sort of kind of remind you of this Satan transformation where we introduce new variables to do certain things yeah and what that little trick is going to be is that it's going to we are going to introduce one new variable okay let's call that variable y and we're just introducing it between here so we're going to add y to the first of these clauses and to the second of these Clauses we're going to add not y okay we're going to add y to the first of these Clauses and to a second one we're going to add not y all right and this helps us somehow Salvage the situation here right because if you had a satisfying assignment now for f you can come up with a satisfying assignment for f Prime in the following way you stare at the satisfying assignment for f yeah so maybe it does this so this is going to satisfy uh one of these Littles in this class so in this case we satisfy this particular letter and none of the others right so since it satisfies at least one of the literals in this clause it's going that the same assignment is either going to satisfy this part of the Clause right the left part of the Clause that you took here or the right part of the Clause that you took here okay so in this case for instance we satisfy the left part of the Clause because we said not x two to one so we satisfy the left part of the clause so since we satisfy the left part of the Clause what we can do is we can use the Y variable to satisfy the right part of the clause okay to satisfy the second Clause here okay so what we're going to do is we're simply going to set not y to 1 which is to say that we're going to set y to zero yeah and now that you set y to zero of course that doesn't help us with this Clause but that's fine because this Clause is always satisfied but it helps us with this Clause because now this Clause was not previously satisfied but now it is satisfied OK and this allows us to transfer a satisfying assignment for f to a trans to a satisfying assignment for f Prime okay so you can see here so this transformation now this is essentially going to be the transformation what so it if you start with a satisfying assignment for f we can transform it into a satisfying assignment for f Prime so we keep the same values for the X variables but we now have to set a value to the Y variable and the way we set it is that this y variable would be set to 1 or 0 one of two cases OK and we set the Y variable to 1 if X1 to x n satisfies the right part of the clause so in this case I guess the right part of the Clause is X 3 or X4 and we set it to 0 if it satisfies the left part of the place which is in this case x one or not x two right so we can extend the satisfying assignment to a satisfying assignment for f Prime by setting the Y variable suitably and we said the Y variables like in this example we said the Y variable to 0 because the assignment to x one to X N already satisfy the left part of the Cross so this is already satisfied we don't need to worry about this so we just set y to zero so that not y is at 1 we satisfy the right part on the other hand if we add an assignment where we satisfied x 3 or X4 already then we did we wouldn't have to worry about this part but instead we would set the Y variable to 1 to satisfy this Clause instead doesn't make sense so this is an idea that we're going to use a couple of times today so it's an important one yeah okay all right sounds good so so now we've argued essentially that if f is satisfiable then F Prime is satisfied but we're not quite done right we for a reduction we also need the other direction we also have to argue that if F Prime is satisfiable then f is satisfiable okay so let's hope that we didn't ruin that part and indeed we didn't so so now let's assume that we have a satisfying assignment for f Prime so this is a satisfying assignment for f Prime then how would we get a satisfying assignment for f right so let me let me do it this way because I know that so only this part that appears on video so uh so if you have a satisfying assignment for f Prime right so an assignment to all the N variables of s and this one more variable y what would be the satisfying assignment for f from here what's the most natural thing to do yes right yeah so so you're saying okay we have these n plus one variables here let's just throw away the assignment for y and just keep the assignments to the other variables right so you're just saying let's just take x one to x n and let's hope that this is a satisfying assignment for f and indeed that's the case because what would a satisfying assignment for these for this formula look like right what is the satisfying assignment for f Prime look like yeah well it would have to set y to zero or to one right you have to say y to zero or one and if it's at y to 0 right if you said y to zero it's a satisfying assignment for f Prime so it must satisfy the left part of the clause and if it said y to 1 then not Y is set to zero and therefore it has to satisfy the right part of the clause so when I go back to F when I put the left and right part together it doesn't matter if I satisfy the left part of the clause or the right path of the Clause I'm going to satisfy the two Clauses put together which is this giant Clause over here so if I just throw away this variable y uh I get an assignment that satisfies all the um foreign so I'm getting I'm going to get an assignment that satisfies all the Clauses of the original formula f and hence f is also satisfied okay so this x one to X N is just a satisfying assignment for f and that's it so that's essentially the reduction right so we we started with the a formula we produce another formula and we show that the new formula is satisfiable if and only if the old formula is satisfiable and hence this is a valid reduction all right so but a couple of things still need to be handled this was the case when I had one Clause of size 4. what if I have multiple Clauses of size 4 what would I do if I had multiple Clause of size 4. I would just sort of repeat this strategy for each of those Clauses and then I would get a bunch of Clauses and every time I repeat this strategy for new Clause I have to use a new y variable right so these y variables shouldn't be shared across classes I want to introduce a new y variable each time and every time I do this I'm sort of preserving the property that the formula is satisfied the way we've built up things so if you add lots of claws of size 4 we'd have to break each one of them separately okay and every time we did this we'd introduce a new y variable and to still Preserve satisfiability so that's how you handle multiple classes what if you had a clause of size five like what if I had instead let me put in a new class here what if I had a clause of size 5. yeah so again we do the same thing we break it up into two clauses right so maybe we break up the first Clause after X2 so we get this Clause here and we get another clause which is why no sorry it's not y not y or X3 or X4 or x five right we get two Clauses one of length one of width three and the other with four yeah and now we already know how to handle Clause of width 4 right we do it once more and we get closer with three okay so now so now let's call this variable y one but I'll have to repeat this process so I'll now do the same thing again to this one which will be not y1 or X3 or Y2 and not Y2 a or X4 or x y okay so so to break a clause of size 5 or width 5 into a bunch of class of width 3 I have to introduce two new y variables now if I have a class of width 6 then I introduce three new y variables and so on so by repeating this process I can eventually get down to classes of width 3. okay it doesn't matter what the length what the width of my original Clauses are I just have to introduce lots of what new y variables and I can keep doing this until my classes have width atmosphere yeah and the same argument shows that if the the original formula is satisfiable then every time you do this the new formula is also satisfiable and the original formula is not not satisfiable then the new formula is also not search okay it's the same argument you just have to iterate this arguments does that make sense okay great uh so before we take a break just a quick question so can we iterate this argument one step further and get Clauses of width two so can be iterated one so if you think about it yeah so some of you are already shaking your head so maybe you see it already but if you don't see it you should probably just go through this argument and think about what would happen if you start with Clause of width 3 and you try to reduce their weight it turns out that you remain with Clauses of width three okay three does not go down to two any further so we're not able to reduce