and it would tell you which person which of the N people it is and this this entry would be zero if it's not a person these other two entries and similarly for a snack this entry would tell you the third entry would tell you which snack it is and be zero in the other two entries because point two percent and same for the drink this will tell you which drink it is and finally the last entry tells you whether it's real or a copy okay so the last entry tells you it's a real or copy so 10 corresponds to real and we will see some other funny numbers correspond to copies so we'll see that okay this funny numbers again they're funny but they are chosen to fit some very well defined constraints so there may be many choices of these numbers that satisfy these constraints I'm just giving you examples okay there could be others all right good so and now you see that I have put together a triple and it's Associated person snack and drink and if I add exactly these vectors together which is what I want in a bin if I add exactly these vectors together I get this Vector at the bottom here in blue yeah and this is going to be the capacity of my PIN okay so my bins have a capacity that's exactly the capacity I need to fit together a person a snack and a drink and disassociated trip okay so you can notice you might notice some funny things about this capacity so for instance if I took a triple but I didn't take its Associated person right if I didn't take I here but I took something else I plus 1 for instance then this column would not add to a zero so you would not be able to match the capacity of the bin that you had so you would not fill up the bin so you either under fill the bin or overfill the bin because you're not going to hit exactly the capacity yeah so so you have the entries of these vectors and the triple so there's a minus I here and a plus I here that's just exactly to ensure that you want to match a triple with its Associated items yeah the person is not your metric okay so all these lots of Tricks kind of in choosing these vectors but when you do you match up exactly these capacities and it's a similar thing for the copies right so I told you what the real versions are but the copies are similar with just a little weirder so uh the first four entries are the same but the last entry when it's a copy it's slightly different so people and snacks are something 11 okay and the drink is an eight so why 11 and 8 you will see why the the we've talked about the constraints already but they have some nice properties eleven eight but there could be other numbers that have these properties nothing very special about 11 and 8. yeah but in any case if you take a person and it's I mean a triple and it the fake versions of all its items the fake drink the fake snack or the copy of the snack and the copy of the person and you put them all together again they add to the same capacity so again they fill up the bin exactly yeah it's the same capacity again you develop the pin exactly yeah and these are the only two ways of filling up a bin okay so the numbers are chosen so these are the only two ways of filling up a pin so you can either take a triple as Associated personal snack and drink the real versions are the copies and uh yeah so I could justify that it's going to take a little bit of time but what I'm going to do is I'm mostly going to skip that so but I'll tell you the the final reduction so we're going to create these numbers for all the triples and all the uh kind of a person's real and copies of the the persons the snacks and drinks the real versions the copies and finally we're going to create a number of bins and the number of bins we are going to create is going to be one per triple right so so here we're going to produce all these numbers that we have so we're going to produce A1 through a so I guess it's going to be something like um four times the number of triples and we're going to produce the number of bins is going to be exactly M so this is the number of bins which is the number of triples and all these bins have the same capacity and the capacity is given by the number corresponding to the bottom blue vector and all these numbers you can kind of convince yourself they're like something like n to the 4. why into the 4 these vectors are of length five and they're encoded in base n okay encoding base n so you're going to take I don't know if you encode the capacity you're going to get 15 times into the 0 plus 0 times n to the 1 plus 0 times into the two and so on and you're going to get something like 40 times n to the 4. so that's going to be the largest number that you get in the Solar encoding so that's why these numbers of size enter before okay and so now uh what you need to do is to kind of argue that the only solutions that you get for the bin packing instance kind of look like this and the reason for this is essentially the way we've set it up the total capacity of the bins is equal to the total size of the items so the only way to find a bin packing is to fill every bin to its capacity exactly so you cannot undershoot any bin because then you won't have room because you then you have to overshoot some other bin to compensate which is not possible yeah so the total sums of the sizes is equal to the total capacity of the bins so you must fill every bin exactly and in order to do this you must do exactly what I said before okay you must fill uh all these kind of bins with a triple and it's Associated real things or Associated copies and I'm going to kind of Breeze my way through this proof yeah so I'm not really going to describe anything in detail so first is that these numbers are chosen the sizes of these numbers so they're all like 10 8 or 11 so they're roughly around 1 4 of the capacity so you cannot choose fewer than four items because if you chose three items you wouldn't be filling a bin so you leave some empty space and that would be a problem later you can choose five items because then you'll be overfilling a bin and that would of course cause a problem so these numbers are all sort of chosen so that every bin must contain exactly four items and now when it contains exactly four items uh it must contain a triple and a person a snack and a drink and this is essentially because of the last column those funny numbers one two four and eight so those numbers are chosen so that when you add four of those numbers to get 15 you must add the numbers one two four and eight you cannot choose you know two fours and an eight then you're already over fifteen you know two fours or two twos and something else so the only way to add four of these numbers to give the number 15 is to take one plus two plus four plus eight okay and so there are yeah so you can see that these funny numbers have all sorts of weird ways of appearing in this analysis right and I'm not going to kind of belabor it but this is the kind of analysis that goes into it so this shows that every bin must contain exactly one Triple A person a snack in a drink so that's that's what the the role of the First Column is to ensure this the roller second column is to ensure that the triple sort of matches the person uh in this bin right so if you have a triple you must have the person associated to this triple in this could be the real or the copy and same for the snack and I drink the next two columns and the final column kind of ensures so this funny eleven eight and ten sort of ensures that you cannot have a real uh person and a fake snack or a real person and a fake drink and things like this right because if you did that then somehow the numbers would not add up to the kit okay so there's some some calculation comp etition something some sort of trickery involved in ensuring that everything goes through right I don't want to kind of get into the minutia of it but the overall idea I hope is reasonably clear right so you come up with these numbers and those numbers almost like kind of fit together like in a kind of a jigsaw puzzle and so that the only way is to fill these bins is in the two ways that we prescribed and if you do this then you see that the solutions to the uh Bin packing problem exactly correspond to the solutions to the tripartite matching problem which means that this is a kind of a proper reduction from tripartite matching to being packing okay all right so uh yeah any questions or comments or okay yeah okay so good so that is the final reduction that we're going to see so on that note let me just kind of end with the kind of retrospective on this module so what we've seen so far is this we created this web of reductions to show that various problems for which we don't have efficient algorithms probably don't have efficient algorithms right so we started with the SAT problem which is uh which was our first NP complete problem and we said that sat every problem in NP reduces to it so if sat has a polynomial time algorithm so does every problem in NP and that was a justification for saying that sat is probably difficult to solve and starting from side we gave reductions to all these other problems so the Hamilton path problem the vertex cover coloring problems so graph problems set problems now numerical problems and other kinds of problems right and this is just the beginning of the story so uh all of these are classical NP complete problems they're probably discovered within a few years of this notion being defined but since then people have expanded the reach of this method much further so there are books and compendia of NP complete problems right so there are lots and lots of other MP complete problems that show up in all sorts of interesting practical and theoretical scenarios and these have to do with different kinds of disciplines including biology and chemistry and all sorts of other things okay and in general if you come across a problem in your daily life that you want to show is ntcomplete so you want to take advantage of this knowledge that we already have right so the first thing you want to do is you want to reduce from some standard problem which is already anti-complete and to by now this theory is so well developed that very often it happens at a very special case of the problem that you're interested in is already an NP complete problem so very very special so you might want to kind of strip your problem down to its Bare Essentials and see if that version is already NP complete and it might be right if not you might find a problem that's very much like your problem that's NP complete in which case you might want to try to modify the reduction from Sac or whatever to that problem and see if you can produce a reduction to your problem instead yeah and finally you know just just Google or maybe nowadays chat GPT or whatever and maybe maybe some chat GPT will be producing NP completeness reductions who knows yeah so yeah so use this knowledge that we have as very uh very frequently this is enough to kind of show that you promise and be completed right so uh and how does this kind of affect your life in practice if you're an algorithm designer so tomorrow maybe you're working uh you're doing a PhD or you're working in a company and for some reason your boss comes and asks you to design a certain optimization problem for a certain optimization algorithm for certain problem and you try for a while you try all the tricks in your book you try Dynamic programs maybe you try greedy algorithms maybe you try linear programs maybe you try something else maybe fancier than that and you don't come up with an algorithm what should you do right you don't want to go back to your boss and say oh I cannot find an efficient algorithm you know you you chose the wrong person for the job this is not a good technique to use in dealing with management instead what you would like to be able to say is go to the boss and say oh I cannot find an efficient algorithm because you gave me an impossible task to solve this is so kind of put the blame on that person that that would be the ideal way to go yeah unfortunately this turns out to be not very practical because it's it's really hard to show that things are interactable okay there are all these things that we believe are hard to solve but we don't know for sure tomorrow somebody could in principle come up with a polynomial time algorithm for sat seems unlikely but it's possible instead the right way to approach your boss is to say that I can't find an efficient algorithm but neither can all these other people right and that's essentially what the theory of NP completeness is right you say that if you if I could have found an algorithm for this problem then we would be able to solve all these other things and we haven't been able to do this for whatever 50 years or 60 years whatever so it seems unlikely that you want me to be able to do this right so this way your boss not gonna be happy but at least they can't blame you yeah so this is uh kind of the way you want to use MP complete test prompts you want to kind of use it as a kind of a sanity check to rule out to say that I shouldn't be trying to cope with an algorithm from this point onwards okay so this is how you want to use the theory of input completes maybe in your daily life but there are also ways of misusing this hit and so there are certain points where you have to be careful when it comes to using this Theory right so imagine that you have a colleague or a friend who comes and says like a friend does that they want to solve some instance of tsp right so they have a kind of a map with 150 cities and they want to find the shortest store that kind of covers all these right so you don't want to think of MP completeness as a kind of a pessimistic tool to kind of discourage your frame right you don't want to tell them uh oh that's that's an MP hard problem you'll never be able to do it that's kind of the wrong way of approaching things right and this is a kind of a common misuse of this uh technique right so what is the theory of NP completeness tells you it tells you that this problem the tsp problem is hard to solve both asymptotically and in the worst case so asymptotically means that this problem gets hard as the number of cities gets really big right and it may be that the number of 150 cities may be still feasible you may have an exponential time algorithm which gets very bad for lots of cities but maybe on 150 cities still works well I mean it's feasible right so certain certain exponential time algorithms really work reasonably well even on moderately sized standpoints and even if it were hard to solve the tsp problem on maps with 150 cities it may be that this particular instance of tsp that you have is still easy so even if the input instance is reasonably large or maybe too large for General tsp it may still be that the instance that we want to solve here is somewhat easy okay so how should you kind of approach the theory of antique operators what should you kind of take home from this right instead so instead of using it as a way of discouraging your friend from working on this problem instead you want to use this more as a scalpel to kind of tell them what approaches will work and what approaches won't so for instance if your friend came to you and said oh I have a linear programming formulation that will solve tsp and I can use this linear programming formulation then you know that there's something wrong with the linear programming formulation right because there's going to be no linear programming formulation that solves all instances of tsp correctly and that's P equals NP so you know that there's something wrong with the linear programming formulation and maybe it's also wrong on the instance that you care about so you might want to warn your friend about that you might want to tell them hey watch out this is not probably going to be correct that's an excellent use and there are other kinds of such uses right so they might have other kinds of approaches uh that might try to find algorithms for tsp so in the next part of the course you want to look at local search algorithms so local search algorithms are certain Nice Class of algorithms that work reasonably well on various kinds of communal optimization problems but nevertheless they are unlikely to find Optimal Solutions to NP hard optimization problems okay so this is not based on P versus NP but on something related called NP versus coenp this is something that you may see in a tutorial this week or may have already seen last week or something like that okay so if you again if you believe under this very well believed hypothesis something like P versus NP there's going to be no local search algorithm to solve NP hard optimization problems and so you can say hey you're trying to use a local search procedure to solve this problem it's unlikely to work for so-and-solies so you want to use the theory of NP completeness not like as a like a buzz saw but more as a scalpel to rule out certain algorithmic strategies and kind of encourage the right kind of algorithmic strategy okay and that's kind of ironic that once you do this you see that there are actually very few ways to solve np-complete problems in practice and these few ways are kind of well tried and trusted well tried and tested so it becomes actually easier in some sense to try and to come up with the algorithmic strategies for NP complete test problems just because there are only a few of them so now by using a theory of NP computers you kind of focus your attention on these few strategies and kind of ignore the strategies that are unlikely to work that's the right way of using the theory of NP completeness in your daily life or you could also kind of lower your standards for what a solution is and instead of trying to find an optimal solution it's the best possible solution you could try to find something that's not exactly the best but close to the best approximately the optimization and this is going to be the focus of what you see in the coming lectures when Christopher is going to come back so we'll see maybe Christopher we'll start on that next week or something else so you get to see then so that's it yeah so stop here unless there any questions or comments or okay cool stop thanks foreign
