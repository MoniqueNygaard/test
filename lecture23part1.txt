the inputs to these problems are numbers or sequences of numbers and we're required to optimize some function or compute some interesting properties of these numbers okay and so something that will play a very important role in what we discussed today will be how the numbers are specified and this is something that we got into right at the beginning of the module Unity versus binary and things like this but we didn't really discuss it since so I thought I would just flash a short question for you kind of illustrating or recalling for you this concept um so here's an example of the kind of question that comes up here so you have an algorithm for computing some number some sort of function of a number a okay so it gets us input a number a and it computes this function of a and the time taken by the algorithm is the square of a right so a squared that's the time taken by the algorithm and now when is this polynomial time so this is depend on the way a is given so a can be specified in unary or binary so and for those of you that don't remember so so if you have a number like five for instance in binary you would specify it as one zero one so that's the binary encoding file but the unity encoding you're not allowed both zeros and ones you're allowed just one of the two so let's take ones for instance so just specify 5 as a sequence of five ones right so that's the unity encoding of five and so when is this algorithm a polynomial time algorithm is it a polynomial time when the input is specified in unary is it polynomial time with the input is specified in binary or is it polynomial time in both situations right a few answers seem to have trickled in so let's take a look you have to say um okay wonderful so uh so the majority of you have said that the algorithm is polynomial time when the input is in unary and that's the correct answer so but just to recall so again uh what is polynomial time mean so the running time of an algorithm is measured as a function of the length of its input and so the longer the input the more a polynomial time algorithm has in terms of running time to still be a fish right so if you have an input given to you in binary so this is a number a right so this is a and let's say it's an input of length n so what can we say about the number a well it's an N bit input so a could be as big as 2 to the n bit input and it's a number so it could be as big as 2 to the power n or something like that so A running time of a squared would be exponential in the length of the input and this would not be a polynomial time algorithm on the other hand if the input a is given in unity and it's of length n then a can only be as big as n in which case a running time of a squared would be running time of n square and that's polynomial time so in order to understand if an algorithm runs in polynomial time or not you want to measure its running time as a function of the length of the input yeah and when inputs are given and unity numbers are given in unary the magnitudes of the numbers are bounded by their lengths yeah so running time of something that's polynomial in the magnitude of the number is also polynomial time in the length of the input but that's not the case when a is given in binary which case the magnitude can be much larger okay and this is a dynamic that's going to show up multiple times in today's lecture we're going to look at running times of algorithms on numerical inputs yeah and sometimes the running times are going to depend on the magnitudes in this way and when that happens the running time is only a problem it's only a polynomial time algorithm if the input is specified in unary but then there are certain other problems which are running time even which are polynomial time even when the input is specified in binary at the linear programming is a prominent example of this there is the input will be specified in binary unary whatever would still be a polynomial time algorithm where ellipsoid so such things are much stronger right so even when the numbers are really really big such algorithms run in polynomial time all right so this Unity basis is a binary Dynamic is an important one when it comes to numerical problems and we're going to see it a few times today yeah and so so let's get started so these are the problems that we're going to look at we're going to look at the knapsack problem which you've probably already seen which you probably might remember from earlier on uh and uh from called the bin packing problem so the the and this sort of illustrates the dynamic the kind of dichotomy between this uh unary binary situation the knapsack problem is going to be an example of a problem that's easy when the input is in unary but hard when the input is in binary the bin packing problem on the other hand is going to be hard irrespective of whether the input is in unary or binary so even when the inputs in unity is going to be really hard and so that's going to be something that we capture where this notion of strong NP height so let's uh kind of look at a little bit more of this to see what you want to do so so we're going to be proving NP completeness of various problems and our starting points are this time not going to be SAT but these set problems that we saw the last time so one of these was the tripartite matching problem like you have these three sets of points and you have triples one from triples containing one point from each set and you want to find these disjoint triples that covers the universe and I'm going to talk more about that when we get to it so I'll recall the definition of the problem for you but we use the tripartite matching problem the last time we first showed that it was npcomplete and then we used it to show that various other set problems were also NP complete and one of these was the exact cover by three sets problem and this is going to be the starting point of our first reduction this time so I just want to recall it so what is the exact cover by three such problems so uh so we have a universe so let me put it in a big box we have a universe of points and the number of points we have is a number divisible by three in this problem okay so we could have six points nine points 12 points whatever so let me call let me start the universe of six points so maybe I have six points here one two three four five six right and I'm given a collection of subsets of these points and each subset has size exactly three okay so maybe I have this subset maybe I have the subset S1 which is one two four and maybe I have a subset S2 which is 356. and maybe a few others right so let's take maybe this one two six and well let's take this one four five six okay so I have a collection of triples from my universe yeah question is so can I partition my universe into disjoint pieces so that each piece is one of these sets so I have six points here so I want to break my universe in this case into two sets of size three but both of these must be subsets among the ones that I'm giving on this right so in particular for for instance in this particular instance I can partition my universe into S1 and S2 so because together these kind of exactly span all the elements might look right sorry so the question is can I partition my universe or my universe if it has size 18 on a partition it into six sets of size three where the six sets are all among the sets that have been given on the okay so that's the exact cover so exact cover cover means that of course every element in the universe appears in one of the sets that you find and exact cover means that every element appears exactly once you don't get to repeat an algorithm so you want to partition the universe into this and this is a problem that we looked at the last time and we showed that it's NP complete by a reduction from type attack matching and we're going to use that in order to argue about the problems that we look at in the first half of today's age okay all right so let's get cracking on the problems that we'll be talking about so what kind of numerical problems are we interested okay so sort of one numerical problem that you've already seen in this course quite a bit is the integer programming problem and here you're given the standard kind of linear programming problem right you're given a bunch of linear constraints yeah so it's a linear programming problem in standard form and you want to optimize some linear function subject to these linear constraints the only difference is that the decision variables are not allowed to take arbitrary real values but must take integer values so that's the integer linear programming problem yeah and so here we have the decision version of this problem so in addition to the inequalities and the objective function we are also given a Target value K and the question is is there an integer solution which is both feasible and achieves an objective function value of least k and so this problem uh I want to argue is NP hard yeah and this argument actually is very simple because we've kind of already implicitly seen these many times in the course already so we formulated all sorts of NP hard problems like the set cover problem and that traveling salesman problem and all these other problems we formulated them as integer linear programs and these formulations of various problems as integer linear programs are essentially reductions from these problems to the integer linear programming so every time you formulate a problem as an interior linear program you're kind of giving a reduction from these problems to integer linear programming problems it's very easy to check that these reductions are polynomial time so in particular the integer linear programming problem is NP hard because all these NP hard problems reduce to it via these reductions so the ILP problem is NP hard so we would also like to say let's NP complete so like to see those problems and to complete and in order to finish the argument that's NP complete we already know it's NP hard we need to argue that this pump is in NP and this unfortunately is not immediately straightforward it's not immediately straightforward and this is different from the other problems that we've seen so far in the course it's always been very easy to see the problems are in NP because you can typically come up with verification procedures that are fairly simple and in this case the verification procedure is not completely straightforward okay so what would be the obvious witness to an ILP uh to a yes instance of ILP here what would be kind of obvious weakness yes right you're absolutely right so a reasonable witness is to give me an an X which has a vector of with the integer values which is feasible and achieves this objective function value right and given such a vector of course I can efficiently verify that it's feasible and achieves a certain objective function value the only problem with this whole thing is what are the sizes of the entries of x it could be that there is a feasible solution that achieves a certain objective function value but the only such feasible uh X has humongous integer entries yeah and just to write down this witness takes a long time so it could in principle be feasible that I mean it could be possible that this is true thankfully it's not true so that it turns out that if there is some X which is a valid witness there is also an X where the entries are reasonably small right but this requires a reason a somewhat complicated argument that we're not going to get into okay so it does turn out that this problem is NP complete but that requires this additional argument I just wanted to say it because it's not completely obvious here and in some cases indeed it's not the numerical problems this can be an issue how big are the numbers that come up in the solution so you want to be able to understand this okay so now let's move on to uh the second problem that I want to talk about which is the knapsack things are a little bit more interesting okay so what's the knapsack problem so you've kind of seen this problem already earlier on in the course I guess when you looked at the integer linear programming but let's kind of uh uh look at it here so so again the knapsack problem so you have a collection of n items right let's call the items one through n and each of these items has a a weight yeah so weights may be W1 through WN and these items also have values B1 to be n okay so you have n items with weights and values and what you have with you is some sort of knapsack and you're trying to fill up the snapstack with a subset of these items but the thing is that your nutsacked can only carry so much weight right so you have a weight budget that your knapsack must satisfy so you have a weight budget p so you can't take all the items you want you can only take the items that kind of so that their weights sum up to at most the value B and now subject to this constraint you want to maximize the value of the items that you pick right so you want to choose a subset of these items so that their weight sum up to Atmos B they fit in your knapsack but their value is as large as possible right and again the decision version is you're given a Target value k and you want to know if it's possible to choose a subset of these items so that the value of the items that you pick is at least key so that's the knapsack the decision version of the knapsack problem and what I want to argue now is that this problem is anti-complete and again the fact that this problem is NP is actually easy yeah because you can just specify the subset of the items forming and that doesn't require specifying any large numbers or anything you just give me the subset and then I can check that the weights and the values satisfy the required properties so this problem is in NP and now let's show that it's empty height kind of concluding that it's simply complete all right and the way we're going to argue that's NP hard is that we're going to actually argue with the argue uh for a slightly simpler problem the so-called subset sum problem so the subset sum problem is a very similar looking problem so again you have n numbers so instead of having two n numbers you just have n numbers here so sort of like n items right but these are not I don't know if we can call them weights or values or something but yeah so there are some n numbers a one through a n and now again you want to choose a subset of these numbers that adds up to exactly some Target value of K it so you have some Target value K and you want to choose a subset of these numbers it's not about exceeding this target value or falling below you want to get exactly this value you want to exactly fit this number okay okay so that's a subset sum problem a it's slightly different from the knapsack problem it's similar because you can have numbers you have a certain Target value but you want to hit exactly that value instead of exceeding or falling okay all right so that's does it make sense for the subset sum problem is okay all right cool so uh let's subset some problems so this is a problem that's actually fairly important in itself so it it shows up in various uh cases of cryptographic problems and other places so it's kind of important to understand uh but what we are going to show in this lecture is that we're going to show substitutes some reduces to knapsack and then that subset sum is then we hired from that Maps okay and let's just let's see if I subset sum reduces to knapsack and that proof is actually fairly straightforward and the reason for it is kind of very simple right so so what do we want to do in subset sum what we want to do is you want to choose a subset such that these numbers add up exactly to K so right we have an equality constraint here and subset sum problem and you probably remember that an equality is just two inequalities right checking if x is equal to Y is the same as checking if x is greater than equal to Y and the check X is less than equal to 1. so an equality is just two inequalities and two inequalities is exactly what we have in the knapsack problem right we have a inequality on the weights and we have an inequality on the values so those two inequalities together can kind of be used to simulate this one equality okay that's the idea of the reduction so it's it's fairly straightforward so let's do it so let's reduce subset sum to knapsack so what are you going to do so you have all these values and now now I want to come up with these weights I'm sorry you have these numbers here to the website and you want to come up with these weights and values so what are the weights I'm going to come up with well I I need n numbers and I have n numbers here so I'm just going to use these numbers okay so these are the weights and I need to come up with values so I have n numbers here I need n numbers I'm just going to use the same and numbers or values I'm going to take my budget to be exact to be some number B but that B I have this number K here I'm going to take B to be equal to K and I have a Target value here that I must accomplish and I'm going to take that to be equal to K as well so I'm going to use the same weights the same values as the numbers in the subset sum I'm going to use the same budget and the same Target value as the Target in the substance so everything is sort of and now you may see already why this reduction works so let's imagine that we have a candidate solution for the knapsack problem if you have a solution for the knapsack problem that's going to be a subset of these items right maybe a subset s says that the sum of the weights in the subset add up to utmost the budget but the budget is K yeah and the sum of the values in the subset the values are the same as the weights here the sum of the values adds up at least to a Target value which also happens to be equal to K and there's just two inequalities which of course is the same as saying that we have the equality yeah so when we do this reduction from subset sum to an abstract what we are preserving is the fact that the solutions to the knapsack problem are exactly the solutions to a subset sum problem so there is a solution to an abstract problem exactly when there's a solution to a substitute some problem and therefore this is a
