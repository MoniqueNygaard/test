foreign good morning welcome back from your Easter break hope you had a nice relaxing week so um thought we'd start back into it with this whole module on NP completeness but since it's been a week or so maybe let's ease into it slowly uh so just as a kind of a short recap what we are trying to do here foreign okay yeah all right so what we're trying to do in this module is try to understand uh these optimization problems and which one of them which ones are kind of hard to solve and which ones have fairly efficient algorithms uh so a notion of efficiency uh for the purpose of this module is this notion of polynomial time uh it's not a perfect notion of efficiency but it's a good proxy for uh building a neat Theory and it's a good foundation to start studying the efficiency of computational problems so we talk about polynomial time and the class of decision problems that can be solved in polynomial time as our basic notion of the efficiently solvable problems and what we want to understand is this large class of problems called uh NP right which are classes or decision problems that have efficient verification procedures so we want to understand in general these problems and so uh and what we want to do is we want to kind of catalog these problems and we want to arrange them sort of some sort of order of computational hardness and the way we do this is where this tool of reductions where we say that a problem reduces to another if we have a polynomial Time map that can kind of use a program that decides one problem to decide the pro the decide another problem so L1 reduces to L2 if you have this kind of polynomial Time map with this property here on the second bullet point to the slide right and so this intuitively for us means that L1 is at most as hard as L2 and using this notion of kind of comparing the computational hardnesses of various problems we want to organize all the problems in NP According to some sort of hierarchy and in particular it would be important for us to identify the hardest problems in this hierarchy which are what we call the NP hard problems which are sort of the the hardest problems in NP those to which every problem in NP reduces so the NP hard problems are really problems that are harder than any problem in NP and the hardest problems in NP which are both in NP and NP hard are called NP complete so this is the kind of the class of problems that we're going to try to investigate and we're going to try to show that many interesting computational problems uh some of which you've been exposed to in this course already are NP complete which sort of shows how this notion is very natural okay and so this is kind of a brief recap but uh maybe just to do a slightly more active recap let's do a short multimeter quiz which kind of uh um recalls some of these Concepts that we've been working with so let me see if I can switch to my window here okay so uh this is just kind of a brief recap of some of the basic concepts we're seeing so just go to mentee.com and uh and try to answer the following question so this question is about a basic foundational assumption that we make in this Theory which is uh called the polynomial Church during thesis so what does the polynomial thesis say so as always feel free to discuss amongst yourselves and okay so I see that there are quite a few answers already so let's see what you're saying okay wonderful so there's a majority uh for one answer but some sort of slight disagreement so it's kind of a good point to have a discussion so again the the church during thesis so without the polynomial adjective the church during thesis simply says that any computational device can be simulated by a turing machine right so it just tells us that the turing machine is the right mathematical formalism of a computer and that's what the church during thesis says and so that's the second Point many of you have chosen that which makes sense right but the polynomial Church during thesis is a stronger assumption the stronger assumption says that any computational device can be simulated by a turing machine only with a slight amount of Slowdown which is to say that if you have a polynomial time algorithm in some sort of computational model right maybe a Python program or it may be something more exotic that we come up with in the future uh any sort of computational model can be simulated by a tuning machine with only polynomial slowdown so you could define polynomial time in some other model but it should be equivalent to polynomial time monitoring machine and this requires this assumption is the polynomial increases so this is exactly uh the third assumption that the majority of you have chosen uh so the advantage of this again is that Turing machines are nice to deal with in certain mathematical situations like when we're approving Cook's theorem in the last lecture there it was useful to be dealing with Turing machines but in most situations you don't want to be dealing with Turing machines because Turing machines are a mess with all the tapes and the you know States and things like that so usually when we write down an algorithm we just write it down in terms of pseudocode and then we can use the polynomial Church during thesis to say that okay if the pseudocode can be analyzed and shown to run in polynomial time then there's also a polynomial time turing machine that does the same thing so it sort of allows us to deal with General algorithms but still say that finally there is a turing machine for this problem okay so that's the importance of the polynomial Church sharing thesis okay um okay so that's the first question so let's go on to the second one okay so here you have a collection of languages three languages so which of these are in NP I hope it's easy to see what these languages are it's a little bit smaller than I intended but yeah maybe it's big enough that you can see it so there could be multiple correct answers in this situation foreign foreign so let's let's see what you have to say wonderful um okay so this maybe requires a little bit of discussion also so uh so again just to recall languages on NP are those that have these efficient verification procedures right so the first language is the language of three colorable graphs and here you have to decide if a given graph is three colorable or not and indeed this language is an NP like the majority of you have guessed and the reason for this is that the verification procedure just gives you a three coloring so you get a three coloring as a witness and of course you have an efficient procedure that can decide whether you have an uh this is a valid three coloring or not so that's efficient uh but it turns out there are multiple correct answers in this problem so I don't know if I set up the multimeter correctly could you choose multiple answers no you couldn't okay so that's that's kind of why okay but uh so it turns out there are multiple answers that are correct uh so the second language is the halting problem so some of you have chosen the halting problem as being in NP and the whole thing from is in fact not in NP uh it's kind of not an NP so it can somebody who didn't choose this can guess why it's not an NP why is it not I guess it's as to why how one might say that this is problem is not in NP yes right so the halting problem it depends on how you state it so my my definition of the halting problem is that you get the description for turing machine and you run it on the empty input and you want to know if it halts or not so this is a decision problem right so either the turing machine halves or it doesn't so in that sense it is a decision problem it's a different question as to whether you can come up with an algorithm for this problem I guess an algorithm for this problem may say give an answer or not but stated as such it's the every instance either yes instance or a no instance so it is a decision from yes it's undecidable right so that's very good the halting problem is undecidable but what about problems in NP can they be undecidable yes so there's a simple verification proceed right so there is no simple verification procedure for the halting problem I guess that's correct but you would have to justify this right so how do you know that there is no simple verification procedure for the holding problem so this requires an argument yeah but it's close to what was said already based on decision based on the fact that language is in NP always have exponential time algorithms right so you know that there is this finite search space there is this space of witnesses and you can always go through all the witnesses and check if there's a valid witness for your instance right so for instance the setting of graph vulnerability you could in principle go through the set of all possible colorings of the graph and check if there's a valid color so you do have an algorithm it's not an efficient algorithm but it's some sort of algorithm that solves the stuff so problems in NP always have algorithms they may run in exponential time but they have algorithms whereas the halting problem has no algorithm that solves it correctly in all instances okay so that's something that separates problems in NP from problems like the halting problem which are much much harder so they are undecidable problems in NP may be very difficult to decide but they can be decided in exponential time okay does that make sense okay so that sets so the whole thing bomb is not NP the third language the uh the lp problem so so some of you have chosen LP as being in NP L3 as being in NP so does somebody have an answer as to why you chose it to be a problem in NP okay all right even if you didn't choose it do you do you have a justification for why it might be in NP so given that so let me tell you that it is in NP the this answer is correct so why might that be the case okay so this requires a little bit of a proof right because okay so uh it's not really clear so an LP in standard form is typically a maximization problem so it's not really clear how to give a verification procedure for a maximization problem where you're asked to show that the optimum value is at most something right because I could give you the optimum solution but it will only show you that the optimum values at least something how would you show that the optimum value is at most something so the way the problem is stated it makes it somewhat unclear how to reason that this problem is an NP but it is indeed an NP because LPS can be solved in polynomial time right so you could just solve the problem in polynomial time find the optimum and then compare it to this given threshold of r divided by S you could just compare this so any problem that can be solved in polynomial time is automatically in NP because you don't need a witness anymore you just solve the problem in polynomial time and that's it so that's your verification procedure you don't need a witness you just solve the problem in polynomial time and check if it's a assist so LPS can be solved in polynomial time uh not using the Simplex algorithm because the Simplex algorithm is worst case exponential time but you've seen polynomial time algorithms for LP like the ellipsoid algorithm so you can use the ellipsoid algorithm solve LPS in polynomial time and then solve the L thing yes right if you modified L3 to instead talk about integer programs then we don't know that it's in P but it is In N oh oh Optimum values is but it's the maximization integer linear program that's what you're talking about right so then it's not clear that it's an NP it's probably not an NP this is like checking if a graph is not three colorable so it's sort of the complement of a language in NP and in general that need not be in NP as far as We Know all right so that's uh nice okay so let's do another one so so we started talking about NP complete languages in the last lecture in particular we spoke about the CNF the SAT problem with CNF formulas so I just want you to tell me here what is a C and F Formula just to recall so it's a Boolean formula which has some sort of syntactic description so which of these formulas given here matches the syntactic description okay wonderful we seem to have lots of answers so let's see what you're saying great yeah um so so just to recall uh quickly so I uh a CNF formula is an and of things so it's an end of things and each of those things are what we call Clauses so a clause is just an R of literals and a literal is either a very a variable or a negated variable so you have this formula F1 here which many of you have chosen correctly to be a CNF formula so you see that it's an and of things each of these things is an R of a variable or a negated variable so that's a literal so this is F1 is indeed the C and F uh the formula F2 here is a little bit different it's an R of things not an and of things and each of those things is an and of literals so this is what we called a dnf formula a disjunctive normal form as opposed to C and F is conjunctive normal form and the third formula is neither an or of things nor a nand of things so it's some sort of Boolean formula but it's neither a CNF nor a dnf so it's something else entirely yeah so uh this this kind of Distinction is important to understand because we saw uh in one of the previous lectures that the sad for the SAT problem the satisfiability problem its hardness depends very much on the representation of the input so the input is some sort of Boolean formula and if it's a C and F it turns out to be NP hired but if it's a dnf it turns out to be prolonged n time all right so it's a good warm-up so let's kind of I had one more question about the sad problem but I think this is a kind of a good warm-up so let's go on to the uh think about the lecture so just to recap um we have these Notions that we introduced in the last few lectures we spoke about problems in P problems and NP and we spoke about this notion of reduction and NP hardness and MP completeness and uh so and in the last lecture we proved on the last couple of lectures we proved this very important foundational result uh here which is that there is some problem that is NP hard and this problem turned out to be the satisfiability problem and it's important to have one NP hard problem in our collection and the reason for this is that now we can show that another some other problems then be hired by just reducing from this NP heart problem that we already have right so recall again MP hard means that all languages in NP reduce to this problem now if all languages in NP reduce to a language L1 and L1 reduces to a language L2 then all languages in NP reduce to L2 by this property of reductions that we've seen already so now to show that some problem L2 is NP hard it's much easier I don't have to talk about all languages in NP I just have to talk about this one NP hard language that I have so it's that's why it's so important to have at least one NP hard language and indeed we know now that there's one NP hard language which is this problem of Sac right so sat is sort of the uh NP hard language that we have and again what is sat so sat is uh so you're given as input AC and F Formula right so it's a formula which is an and of Clauses and the question is is there a satisfying assignment right so if you have an end of Clauses a satisfying assignment is just an assignment that satisfies each Clause individually and to satisfy a Clause right a clause is just an R of literal so it may be something like X1 or X2 or not X3 so a clause an assignment satisfies a clause if it satisfies at least one of the literals of the Clause so either x one is set to 1 or X2 is set to 1 or X3 is set to zero so any one of these three things would satisfy this Clause so an assignment that satisfies this cause would satisfy one of these three conditions and of course an assignment satisfies the whole CNF formula if it satisfies all the Clauses in it so the hard part is that you have to get you have to satisfy a bunch of Clauses simultaneously and that's when the formula is said to be satisfied so we looked at a few variants of sank we looked at circuit sat so circuit sat is when you're not given a c in a formula but instead you're given a circuit right so a circuit is sort of slightly more complicated representation of a Boolean function which looks something like uh like a graph right so you have you have your variables and then you can take hours of these variables and then you can take ands of these things and you can recursively sort of compute more and more complicated Boolean functions that's what a circuit looks like and in a circuit set in the circuits are problem you are given a circuit like this and the question is is there an assignment to the underlying variables that makes the circuit output one that makes this this gate on top say one that's the circuit set problem and the way we showed that sat was NP hired was we first showed that circuit sat was np-hired right and this was the content of the last lecture it's a main part of Cook's theorem and then we reduced circuit sat to sort of CNF sat we showed how to reduce this to this okay so that was the sound of the picture and now that we have sat we want to start reducing to other problems like graph theoretic problems and other kinds of problems that we want to show to be NPI but the thing is that we need to work with sat a little bit more because it's stat is sort of a very good static point but it's not a bad starting point so like what we're going to do in this lecture today is we're going to look at restricted versions of sat okay and then we are going to try to understand when those restricted versions are NP hired and when they turn out to be actually in polynomial time okay and this will give us a good starting point for now for starting to reduce to other problems which will start which will do in the next lecture okay so what kind of restricted variants of sat are we going to look at well what we're going to do is we're going to parameterize Sat by the width of these Clauses okay so how big these Clauses are all right so what we're going to do is we're going to look at these problems called KSAT so what is K sat so K is about an integer parameter so it's going to be three or four or five or something and the the the variant of sat that we call KSAT is the variant where the CNF formulas that you have have width at most K right so every Clause can contain at most K variables ok so for instance a three set formula would have Clauses of width at most three so it could have things like this it could have you know x one or not x two it could have just x one so all of these Clauses could appear in a three CNF formula okay if you have a force in a formula you could also have Clauses of width 4 and a five CNF formula could have classed with five and so on but a three c and a formula cannot have Clauses of width four okay and three side is just a problem of checking if a three C and F Formula is satisfied so you're given a c in a formula but it's not a general C in a formula it always promised to be a three CNF formula and you want to know if it's satisfiable or not and the same for any K set you're given a KC and a formula and you want to know two times will make sense so just by the definition of the problem you see that k c n f sat is sort of an exact a special case of sat right because in sat you're given an arbitrary CNA formula there is no bound on the width of