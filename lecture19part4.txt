these kind of logical cancellation operations and derived new Clauses and things like that so the second algorithm is also the same kind of idea in Disguise but it's sort of more graph theoretic so it sort of based more on understanding a graph related to two CNA formula so if you are a person that likes graphs more than formulas maybe this algorithm will appeal more to you so let's go through it yes I don't need this yeah so the way this algorithm proceeds is that we the first thing we do is we rewrite our CNF formula it's a two CNF formula we rewrite it in terms of what are called implications so what is an implication so an implication is a very very simple kind of statement about Boolean variables so you say that X implies y and kind of intuitively that's saying in language that if x is true then Y is true if x then y right that's an implication so if I think of X and Y as Boolean variables yeah yeah when is this implication true this implication is definitely true when X is true and Y is true so that's a place where the implication is true but this implication is also true in some other situations it's also true when X is false right and when X is false this implication doesn't really say anything y can be anything so y could be 0 or Y could be 1. so you have this implication that says if x is true then Y is true so there are three ways of satisfying this implication you could set X to true in which case you'd have to set y to true or you could set X to false and you could set y to anything right those are all uh kinds of ways of satisfying this implications so this kind of logical implication this doesn't hold in general in everyday language when we say if a then B we don't always mean this but in a logical sense this is the meaning of an implication so the only way to not satisfy this implication to not satisfy this implication would be to set X to 1 to true and Y to false right that's the only way to not satisfy so all of these are satisfying so satisfying satisfying satisfying this is not satisfying so this is kind of a Boolean function on two variables yeah and it has only one non-satisfying assignment only one way to not satisfy the Boolean function so we've already seen that Boolean functions that look like this are just Clauses right so this is just a clause in Disguise so what Clause Is it is it it's the Clause that rejects this assignment and accepts all the others it's that particular class so what Clause is that that's going to be not X or Y you see on the slide probably already not X or Y okay so it's so an implication is just a fancy way of writing down this class conversely every Clause can be written as an implication like you see on the slide so let's start with some two CNF formula so f is a two CNF formula so let's write down some two CNA formula so let's say I don't know X1 or X2 maybe um x 1 so if you put an and here sorry and X1 or maybe not x two and maybe x 2 or not x three let's put in one more and X1 or X okay so it's just a bunch of clauses right and so we can translate each of these Clauses into implications instead okay so how are we going to do it well if I look at the Clause x 1 or X2 it does not quite look like this neither variable has a negation sign in front of it but I can think of this Clause as simply not not x one or X2 right I can think of it this way yeah and now it looks like an implication because it's not of something or of something else so this is just the implication not X1 implies X2 is the implication not X1 implies X2 right so every Clause can be turned into an implication by sort of introducing a bunch of not operations yeah you may have to introduce a few not operations but you get this conversion to an implication so we turn the Clause x one or X2 into this implication by introducing some not operations in front of X Y we could also have introduced these not operations in front of X2 like you see in the slide there so you would get in that case you would get a not x 2 implies X1 so you can turn a clause into an implication and typically there are two ways of doing it you can say that one implies the other by introducing a not operation in front of one of them or in terms in front of the other does make sense okay so you could also let me just as an example show also the second Clause so X1 or not X2 so I can think of x one again as not not x one so then I'd get not X One implies not x two or here I already have a knot so I can just write X2 implies X1 and so we have implications two implications equivalent implications for any uh clause in this two CNF formula so we can write this entire two CNA formula just in terms of a bunch of implications right so now instead of Clauses we just have implications we have a conjunction of implications and we want to satisfy all of them yeah and the only way remember to not satisfy an implication is to do this that's the only way to not satisfy an implication everything else satisfies the implication so now we're going to reason about this but we're going to reason about this in the language of graphs okay so we're going to turn these bunch of implications into a graph okay so how do we do this so this graph has as vertices the literals in the formula so in this case I guess there are three variables so six literals X1 X2 X3 and I guess not x one maybe not x two not x three okay and now what we're going to do is for every possible implication that we added to our two CNF formula we're going to add an edge to this graph okay so every Clause turned into two implications so for every Clause we have two of these implications so we're gonna they're gonna be two of these edges here so let's see what kind of edges we get right so X we had not X One implies x two so obviously we add The Edge from not x one to x two and we put a direction here we stop it just before okay but we also saw that it's the same as saying not x two implies x one so I can also add this edge here so we have that so those are the two edges for the first clause and then we similarly have two edges for that for the second Clause so which one should those be those would be X2 implies x one and kind of the reverse Edge on this side which is not X One implies X 2. yeah then there's the third clause which I guess is let's see this X3 implies X2 and not X2 implies not x three and finally we have not X One implies X3 so that's like this and not X3 implies X1 and this graph is what we'll call the implication graph of the formula okay so we start with the formula we turn it into a bunch of implications and we draw this graph here the implication graph of the function okay and it's going to be easy for us to reason in terms of this graph in order instead of understanding sort of The Logical structure of the formula or rather it's we're going to be able to understand the logical structure of the formula by reasoning about this graph so let us make a few observations right right so the first observation is here so let's make a few simple observations about this graph right so the first observation is very simple is that every time we added an edge from uh you know I don't know so let's say we added an edge between a literal between two literals L1 and L2 every time we added an edge this way we also kind of add a reverse Edge right so we added edges in pairs so every time you add an H from L1 to L2 we also added an edge from not L2 to not L1 okay we kind of added a reverse Edge so we did this for X1 and X2 for instance we added an edge from what is it not where was it again is not x one to X2 and then we also have an edge sorry not x one to x two and then H from not X2 to x one so we added them in pairs yeah and this has some effect on the graph so for instance you could have a pair of edges so maybe you have a literal L1 and you added an edge to a little L2 and you added another Edge from L2 to L3 yeah then you would have the corresponding reverse edges you would have the edges from I guess not L one two not L2 and then Edge sorry my finger I'm not going I'm not going the right way sorry so it's an edge from not yeah so it's an edge from ah not L2 to not L1 and also a reverse Edge from not L3 to not L2 yeah sorry I got confused a little bit there so uh every time we add an edge from L1 to L2 we also have the reverse Edge from not L2 to not L1 so if you have a sequence of these edges that we put together right L1 to L2 123 then we have the sequence of reverse edges from not L three to not L2 to not L one yeah so we can kind of change these edges together more generally what this means is the following is that you have if you have a path between two literals right so if you have just some path you could have lots of edges from L one to maybe some L3 then you would have the reverse path from not L three to not L one okay so we you'd always have every path kind of has a reverse path yeah if you have a path from L1 to L3 you have a reverse path from not L3 to not L one so part the reverse path kind of goes between two different literals but it's sort of the reverse of the original path yeah and this is just a consequence of the fact that we added edges in pairs to this graph that's sort of a one observation the second observation is that these paths from literals between literals tell us something about The Logical structure of the underlying CNF formula so what do they tell us about the logical structure of the underlying scene of formula well we know that if you have two implications right so if you have two implications maybe L one implies L2 and L2 implies L3 you can change these implications together to get an implication L1 implies L3 that is kind of a logical fact right if you have uh I don't know fact a implies fact B and fact B implies fact C then fact a implies fat C so you can chain implications together and that tells us something about paths in this graph right so if you have a path from L1 to L3 which might be a really long path that sort of corresponds to a chain of implications and you can chain all these implications together to get an implication from L1 to L3 right so if you have a path in this graph from L1 to L3 that means you have a collection of implications in your formula and you can chain all these implications together to get a direct implication from L1 to L3 right so this implies so if I have a path from L1 to L3 this part goes like this then L1 implies L3 is a logical consequence of the formula yeah so let's see if you can derive some logical consequences in this formula here so for instance we have here x 3 implies X2 and x 2 implies X1 so we have the logical consequence x 3 implies x one as a consequence of the implications we already have right so in this thing we can get a path from x 3 to x one so x three into X1 yeah so we have a logical consequence from X 3 to x one in particular any satisfying assignment of the formula must also satisfy the implication that x 3 implies X1 so you can't have a satisfying assignment to the formula that says x three to one x one to zero that can't happen yeah because x 3 implies X1 is a kind of a logical consequence of the implications that we already have in the formula so we can use the implications that we already have and kind of derive new implications and we can see that as looking at paths in this graph and you know and when you have one vertex that's reachable from another via path in this graph you get a new implication that follows from the old applications so these kind of logical consequences can be derived as Parts in this graph which is why it's nice to look at this graph in some sense does it make sense these two facts so the second fact is going to be really useful because we're now going to use this to derive facts about whether this formula is satisfiable or not satisfiable so let's look at this formula here that the one that we have I have a path here from not x one right 2x3 and from X3 to X2 and from X2 to X1 yeah so I have this giant path from not x one to X1 okay so what does that mean so let's say I have some variable says that I have a path from not X to X in this graph right that means that the implication not X implies X is a logical consequence of my formula right not X implies X is a logical consequence that means that X cannot be set to false right because if x was set to false then not X would be set to true but a logical consequence of my formula is that not X implies X so X must be set to true but X cannot be set to both false and true at the same time right so a logical consequence of my formula is that not X implies X so in any satisfying assignment X cannot be set to false X must be set to 2. so this implies that X is set to 1 in any satisfying assignment this is sort of a delicate point so is there any questions about this okay so uh yeah so this is kind of a this is the main kind of thing that we're going to use in our analysis so if you have a path from a negated variable to a variable then the variable must be set to true in the Same by the same token if you have a path from X to the negated form of X then X must be set to false okay the same argument again if x was set to true then not X must be set to true but X and not X cannot both be set to true so X must be set to force all right so that's it uh so this gives us an idea for how to set variables uh in a way that to satisfy the formula and in particular this forces X to be either 0 or 1 in these two cases and if you have both of these things simultaneously It's the final observation that if you have both a path from X to not X and from not X to X right if you have both of these parts then X can either be set to True nor to false the formula therefore must be unsatisfiable okay so in this case the formula is unsatisfiable okay so if you have both a path from X to naught X that means X implies not X so X must be set to 0. on the other hand if you also have not X to X then X must be set to 1 and it cannot you can't have both so the formula is unsatisfied okay so just by reasoning looking at Parts in this formula you can derive all sorts of interesting things about the formula in particular if you're able to derive Parts both from a variable to its negation and the other way around you see that the formula is unsatisfiable okay so it's a purely graph theoretic way of reasoning that the formula is unsatisfied and it turns out that this is essentially uh an if and only if statement so the formula is satisfiable exactly when you don't you can't derive that it's unsatisfiable this way for the formula to be satisfiable it's both necessary and sufficient that there are no pair of parts of this kind so there is never a variable X such that you have a path both from X to not X and not X to X so there's no path going in both directions okay does this make sense I mean this Criterion I may have lost many of you in this in the description of this but hopefully the graph theoretic Criterion for checking uh satisfiability is somewhat clear is that if I want to check if f is satisfiable I just go to this graph and I look at every variable so I look at X1 and I check is there a path from X1 to not x one and a path from not X1 to X1 if so the formula is unsatisfiable otherwise I go to X2 and I check if there's a path from X2 to not X2 and not X2 to X2 if so the formula is unsatisfiable and then I go to X3 and I do the same thing and if in any case I find both of these parts then I declare that the formula is unsatisfiable otherwise I declare that the formula is satisfiable so that's that's what I do and that's the algorithm for checking satisfiability and this theorem tells us that the algorithm is actually correct so the formula is satisfiable if you're not able to declare it unsatisfiable this way I did have a proof of this theorem I've got five minutes remaining uh so it's a yeah it's a little bit of a question as to whether I should do it so let me see let me see how much of this theorem I can get across and uh yeah let's see how it goes so it's actually a fairly simple theorem so we already argued that if you have a path both from X to not X and not X to X that the formula is unsatisfiable what we need to argue is if there is no pair of parts of this kind no pair of Parts like this then the formula is indeed satisfiable and in fact you can build a satisfying assignment from this condition so when you never have a pair of Parts like this you can always build a satisfying assignment like and the algorithm is extremely simple so what you do is that you just go through the variables in this formula right you go through the variables and for every variable so you're going to set the variables to either zeros or ones so let's go through the variables in this formula for instance so for every variable you're going to set it either to 0 or 1. so let's look at start with the variable X1 for instance so in this case there is a path from not x one to X1 right so if there's a path from not x one to x one so what we do what we know therefore is that when there's a path from not X to x x must be set to 1 right so in this case we set X to 1. so not X Y to zero Okay so we've set x one to one and not x one to zero but when we set x 1 to 1 we know that you know so if you have any implication from X one to anything else in the formula that other thing must also be set to one so we have to go ahead and set all those other literals that follow from X one also to one we're sort of Lucky in this example in that there are no literals that follow from X one so there's nothing more to do so we just go on to the next iteration so in the next iteration we choose a new variable so in this case we choose the variable X2 for instance right and now is there a path from X2 to not X2 or not X2 to X2 I guess there's no path in either direction in this case so we just set not X2 we can set X2 to anything we like here so in this case let me just set X2 to 1. and therefore not X2 to 0 and again we have to look at everything that follows from setting this thing to one and we have to set that to one as well so the only thing that would follow from setting X2 to 1 here is X1 but that's already set to one so we're in good shape and then we go to the next literal and again we do the same thing so we set x three to one maybe and not x three to zero and again we set everything following this x three to one but thankfully there's nothing to set in this case so it all say it all works out okay and that's the sort of the general algorithm the general algorithm is to look at variables that have not yet been said and for any variable that's not yet been set whose value is forced to either one or two zero it's forced to either one or two zero you just set the variable in the way that it's been forced and when you set something to one you have to set everything that follows from that to one as well so you have to set all that to stuff to one and in the end you're going to be left with a satisfying assignment because you would have set all the variables so there's a little bit of an argument required to show that indeed what we get is a satisfying assignment uh but I'm kind of run out of time so I'm not going to do that argument so the argument is in this textbook of Papa Dimitri which has been shared on brightspace so you can take a look at it there uh but otherwise this is the algorithm and that's kind of a graph theoretic algorithm that also shows that two Sat is to open in polynomial time okay so I guess that's all I wanted to say for today so let's stop here