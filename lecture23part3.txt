in my knapsack and if I decide to ignore item I plus 1 then essentially what I'm looking at is just the first I items and that's sort of some entry in the first I Columns of my table and that I already know because I've already filled in the first I columns one thing okay so if I decide to ignore item I plus one I already know the answer if I decide to take item I plus 1 in my knapsack then I have to choose some subset of the items from one to I but my weight budget is now reduced by the weight of the item that I just took if I took item I plus one my abstract my weight my weight budget is reduced but now again I have to choose a subset of item from one through I and again that's some value that I already computed maybe it's up here and so now using these two values you can combine them to get this value here okay so the value in the I plus First Column is a simple function of the of two entries in the ith column and these entries this function is given up there so what you can do is just kind of run this algorithm and compute each of the entries and what we get is an algorithm that runs in time polynomial and the size of this table and this is going to be polynomial time if the size of the stable is small and that sort of depends on the budget of the algorithm okay so yeah so I want to say a little bit more about the running time of this algorithm and what this means for other similar problems but I think this is a good time to kind of take a break yeah and uh come back in 15 minutes and then I'll tell you a little bit more about this boss all right so uh welcome back so let's continue so we're talking about the complexity of these numerical problems and what we saw was this very interesting uh uh Phenomenon with the knapsack problem so when the numbers are allowed to be exponentially large we saw that knapsack is a generalization of subset sum and subset sum is np-complete right but whereas the numbers are kind of small right so if you imagine that the budget of the knapsack is only polynomially large then you have this algorithm that runs in polynomial time and solves the problem okay so this is an example of a problem that's easy when the numbers are small and hard when the numbers are large so in other words if when the numbers are given in binary when the numbers are given in binary a length n input can encode binary numbers that are up to 2 to the N so you can encode really big numbers in this case the knapsack problem is NP hard on the other hand the unary version yeah in which case length and input can only encode numbers up to n then the problem is actually in polynomial time and when this happens we say that the problem has a pseudo polynomial time algorithm so it's a polynomial time algorithm that is a it's an algorithm that runs in polynomial time as long as the numbers are bounded by polynomials numbers are not too big and this is a very general phenomenon so it occurs for knapsack that the different there's a difference between the unary and binary encoding it has a pseudo polynomial time algorithm but there are many other interesting problems that are this way in general if a problem Q has uh an efficient algorithm in the unary encoding then we say that as a pseudo polynomial time algorithm but in some cases even the unary version turns out to be NP hard so even when the numbers are pretty small the problem turns out to be really difficult and be complete then we say that it's strongly NP hard or NP complete so strong NP hard problems only make sense for these numerical kinds of problems and it means that these problems are hard even when the numbers that are involved in the input are relatively small only you know they can be given in unary for instance so only polynomial and so this is a very strong statement to make about a problem so it's strongly NP hard right that even when the numbers are really small the problem is difficult nevertheless many of the problems that we've seen already numerical problems are strongly NP hard so knapsack is not strongly NP hard because it has a pseudo polynomial time algorithm but the integer linear programming problem for instance is strongly and be hard and you can see this by looking at the formulation of various NP complete problems as integer linear programs right so when you look at tsp and you modulate as an integer linear program you don't really introduce any large constraints okay so if you sort of follow the chain of reductions from Hamilton path to tsp to integer linear program and you look at the program that comes out it's not really there are no large uh numbers in this so you might as well write them down in unary notation and the reduction wouldn't take very long so you can think of this as a reduction from Hamilton path to the unary version of integer linear programming so even in the unary case this problem is NP hard so it's strongly amp behind yeah and I'm going to the final kind of MP completeness reduction that we're going to see in this module is going to be another example of a problem like this and it's a so called bin packing problem okay so we're going to show that a very this very interesting problem is strongly NP hard so it's NP hard even when the numbers involved are only polynomially large okay so let's uh first talk about the problem itself so what's the bin packing problem so you have a collection of items so again items and now you have numbers associated with items which are the sizes of these items okay so you can think of these numbers as the sizes of these items and then you have a collection of bins so we'll assume that we have a certain number of bins B bins and each of them has a certain capacity C so tells me uh tells us how much each bin can contain so all the bins are identical they're B bins of capacity see so given all these things is input so you know how many items you know the size of the items you know the number of the bins and you know the capacity of all these payments and now what you want to do is you want to fit all these items inside the pins right subject to these capacity constraints so obviously you cannot over fill a bin that's what the capacity tells you and now subject to these constraints can you actually fit these n items into these B bins yeah so that's the bin packing question and what we are going to do is we're going to show that this problem is NP hide even when the numbers are small okay so what are the numbers here the numbers are these sizes A1 through a n so those are the numbers and the capacity is also a number so that's the size so this is going to be small as well so all these numbers are going to be relatively small they're going to be some polynomial uh in N which is like n to the 4 in this case and so we're going to show that this problem is already in hired so it means that even the unity version of this problem is NP hard therefore this is strongly NP hunt okay so there's a very special case of integer linear programming you can very easily formulate this as an integer DNA program but even this very special case is already NP hard and this case by itself is kind of useful in modeling various interesting algorithmic problems yeah so does this make sense the statement of the problem and what we're going to do okay all right so so if that's clear so now I'm going to kind of Breeze through this reduction yeah so this reduction is not the easiest reduction in the world the reason for it is that so far all the reductions we've seen have been kind of nice reductions to graph problems where there are geometric ways of drawing things and describing the gadgets here the gadgets are not geometric but they're more numerical okay so they are you find funny collections of numbers that have interesting properties so it's not as easy to describe you know by pictures or something like that so it's going to be harder to describe but I'm going to make my job easier but not describing him yeah so I'll just present to you these numbers and I will tell you the interesting properties that they have but uh it's hard for me to give you an intuitive picture on the board of what this means so so in that sense it's a little bit harder but it's a very fun reduction and it would be sort of one of my top favorite reduction service goes if it went for the case that's sort of harder to Intuit okay so let's get on with the business so what we're going to do is we're going to kind of reduce tripartite matching to this problem so let me start by just recalling the tripartite magic problem so what's the problem so it's very similar to the exact cover by three sets but this time the universe is divided into three sets of equal size so so we called the last time we had this thing where we said these are people snacks and drinks yeah and you have an equal number of each so maybe you have in this example let me take two people uh two snacks and two drinks right and these people are you know they have preferences amongst these snacks and drinks so maybe the first person uh likes to have snack one with drink two or uh snack one we drink one maybe like snack one you can have if it both but they might also like snack too we drink one and whereas the second person is maybe a little bit more picky so they only like snap one paid drink I don't know uh let me see so yeah let's take drink two okay so so these are preferences so uh we could draw a picture by saying that person one likes snack one and drink two they like snack one and drink one they like snack two and drink one that is person two only likes snack one and drink two okay so this picture is a little bit complicated so it's not the easiest to understand which is why we have the sets on the side there all right so now uh and the question is can you allocate this food to these people these two people respecting their preferences so that you know nobody goes hungry and nobody has to share a snack or a drink so uh what we could do in this case I guess is to allocate a person one snack two and drink one and person two snack one and drink two and uh this would be a valid uh answer solution to the problem okay and the question is is there a valid solution like this right that's the tripartite matching question and we're going to reduce this now to bin packing so we have in general a so we're going to reduce tripartite matching to bin packing so in general we have a set of people instead of snacks set of drinks and a set of triples that encoder preferences so we have the same number of people snacks and drinks in and we have a set of M triples that encode people's preferences and from here we want to produce this bin packing instance which is all these bin item sizes and bins and capacities and then the question of tripartite matching we would like to reduce it to this bin packing question so how are we going to do this yeah so the idea of the reduction is kind of simple yeah but yeah it will require some tricks to make it work so the idea of the reduction is that the items that we're going to produce are as follows right so so let me do it on this example here so I have four triples so let's call this triple something let's call them maybe T1 through T4 yeah and the idea of the reduction is that I'm going to produce a collection of items so they're going to be four items correspond to triples T1 T2 T3 and T4 okay so gonna be four of these but I'm now I'm going to produce more items corresponding to the people the snacks and the drinks so corresponding to the first person right so the first person P1 here this person participates in three triples so I'm going to produce three items for this first person okay yeah and you will see why in a second but the first item is going to be called the real item and the remaining two are going to be called copies so there are three items one is real and the remaining two are copies and the same for the second person the second person only participates in a single triple so I just have the one real copy that I keep so that's Pete and the same for the snacks and the drinks we don't really distinguish so S1 appears twice so there's one real and one copy S2 is a real and a copy D1 and D2 again one real and one copy each okay so those are all the items we're going to produce we're going to produce all these items and so what's Our intention in doing this well so these items are going to have sizes so I'm going to tell you what the sizes of these items are in a second right so we're going to so so these are the so we're going to have a these items so so I'm going to give produce sizes for these items a second but the idea is that when I take a bin right this bin is going to be able to fit a triple T1 for instance so T1 is this triple yeah and it's going to be able to fit P1 S1 and D2 along with it so it's going to be able to fit P1 S1 and D2 along okay and the sizes are going to be such that these four items when you put them together in a bin they exactly fill the bin okay they do exactly the right thing but the only way to exactly fill the bin is to do something like this I could take a triple and I could take all its associated real items okay the real person the snack and the drink that are associated to this triple and I put them all together and that's going to exactly fill the PIN yeah and this is essentially one just one of two ways to fill the bin okay so it's almost like finding jigsaw piece of a jigsaw puzzle that kind of fit together perfectly so a triple and its Associated person snack and drink the real copies are going to exactly fill a bin right so and that's going to kind of help me fill some of the bins right so what I'm going to do is so I have my perfect matching here so there are two of these right these two formed a tripartite matching so I'm going to take T3 and I'm going to put in the real copies P1 S1 S2 and D1 and T4 and I'm going to fill in a P2 S1 and D2 okay and that's going to fill in two of the bins right exactly but this doesn't take care of all the items right there are two triples that haven't been chosen at all so T3 and T4 are gone but T1 and T2 remain so what we're going to do is we're going to fill two more bins one with T1 and one with T2 but now we're going to use the copies and this is where the copies are useful the copies are useful in kind of taking care of the rest of the triples they are not in the matching okay so now I can take T1 and now I'm going to take the copies of P1 S1 and D2 P1 Prime S1 Prime V2 Prime and that's going to again fill up another bin okay and this is going to be the second way of filling up a bin so I can fill up a bin exactly in two ways I can take a triple I can take an Associated personal snack and drink the real copies and I can fill up a bin or I can take a triple and take the fake copies of what its Associated persons that can drink and that's going to be the second way to fill up the bin and the same for T2 and that's going to be P1 double Prime I guess S2 Prime and that's going to be the overall uh packing instance that's going to be the solution that gives me the perfect match okay so now we have to come up with numbers such that every time we have a perfect matching we have the solution that kind of fills up these bins exactly and the only way to fill up all these bins exactly is to come up with a solution like this this is the only way to do it so you shouldn't be able to for instance put two triples in the same bin you should not be able to put two people in the same pane you should not be able to put a triple and a person that's not associated to a triple in the same bin you should not be able to put a real cop real person a fake person a real person and a fake snack and all these bad things that are not covered by these examples you should not allow that to happen and if that happens it should be the case that it doesn't lead to a bin packing right so so those numbers are chosen in a kind of a magical way that ensures that all these things together happen so now some magic is going to happen when I show you the numbers but you have all these constraints that kind of dictate what these numbers are right okay all right so there's going to be this real occurrence yeah so this is exactly what we want to happen right every bin contains four items a triple and it's Associated real things or a triple S Associated fake things okay good so this is all these constraints that I told you about more or less than four items you cannot have two triples persons snacks or drinks you cannot have a triple A person snack or drink is not associated to it you cannot have a real copy and a fake copy Etc okay so now you get to the magic okay so now I have to tell you numbers but I'm not going to tell you numbers I'm going to instead tell you vectors okay these are vectors of length five right and we already saw in the first half of the lecture how to convert a vector to a number right by working in a large enough base so we kind of convert a vector to a number in a certain way and we're going to work in a large enough base something like 4 times n and that will kind of that's kind of enough for this application to convert these vectors to numbers okay so I'm just going to tell you the vectors and additions of these vectors are going to correspond to adding those numbers together because we are working in a large base where carry is sort of not a problem yeah so that's it so we're all set so so these are the real copies right so so-called real copies so uh this is a triple yeah triple is always a real triple there's no fake copy of a triple so a triple and it it's Associated Vector is this thing here the fourth row of this table and uh the the the person the snack in the drink belonging to this triple are its Associated vectors are these vectors up here the first three rows so it all looks fairly magical but let me just tell you what the different entries kind of correspond to yeah the first entry of this vector it tells you whether it's a person a snack or a drink or a triple so it tells you kind of the type of the item okay so uh one two four or eight it tells you the type of the atom so that's the first entry the second entry if it happens to be a person it tells you which person it is right so in this instance we had two people but in general of course you could have n people
