valid reduction reduction okay yeah okay so that's a pretty nice and simple reduction so now what we want we're going to show to kind of complete the loop here we are going to show that subset sum is uh NP complete so let me reclaim some space on my whiteboard here because I don't need knapsack anymore and let's show that subset sum is uh NP hard because it's easily Inlet so let's show the subsystem is empty heart and the way we're going to do it is that we're going to reduce this problem the exact cover by three sets problem basically change so let's I'm going to do take the exact cover by three sets problem and I'm going to reduce it to subset sound okay and in the exact cover by three sets problem I have this universe so maybe some Universe U and I have a collection of subsets of My Universe and I will now produce a collection of numbers A1 through a so how many numbers am I going to produce it will turn out that I'm going to produce a collection of numbers which is exactly equal to the number of subsets that I have in my exact cover by three six problem so I have M subsets here so I'm going to reduce M numbers here and I'm going to produce some Target number and again what we are going to ensure is that the solutions to the subset sum problem so the subsets of these numbers that add up to K correspond exactly to the solutions here which are collections of subsets here that partition the whole universe so like for instance here the solution the only solution is S1 and S2 so that's going to correspond to a solution of the reduced subset sum instance and everything else is not going to correspond to a solution of the reduced substance so that's going to we're going to preserve exactly the solutions that we have and so how do we do it so I'm going to do this in two steps so the first step so in subset sum I want to produce a collection of numbers but in the first step I'm going to do something else which is a little bit weird okay instead of producing numbers I'm going to produce vectors okay and so what are vectors right vectors are just sequences of numbers so it's not a single number but a sequence of number okay and I'm going to produce a Target vector v okay so I have a collection of vectors and a Target vector and again I want it to be the case that uh I want to find a subset of these vectors that add up exactly to my target width yeah so it's kind of like a vector version of subset sound first reduce the problem that we're starting with to a vector version of subset sum going to be it's kind of weird but it's going to be very simple to do this and then we're going to reduce Vector subset sum to good old numerical subsets huh and that's going to involve a trick that will be useful in the second half of the lecture as well so it's a good trick to know okay so this is how the reduction is going to go it's two steps reduction to vectors and then reduction to numbers and let's see what we're going to do uh for the the first part on this example here so I'm going to produce now from these four subsets I'm going to produce four vectors okay and I'm also going to produce a Target vector and so what are these four vectors so let's write them down so so they're going to be four sets right so S1 S2 S3 S4 I'm going to produce a vector for each of them and these vectors are going to be lists of numbers and the lengths of these lists is going to be exactly the number of elements in my universe so I have six elements in my universe here so let me write those down one two three four five six so these vectors are going to be lists of length 6. okay so now let me tell you what the vectors are okay so let's look at the vector corresponding to the first set okay the first set contains the elements one two and four okay and so the associated Vector is going to have a 1 in the locations one two and four and it's going to be zero in the other locations okay so that's the vector so it's just a zero one vector it's zeros in the locations not in S1 and it's one in the locations in S1 okay so it just tells me exactly where what S1 is and we're going to do the same thing for S2 so S2 has 3 5 and 6. so we're going to put in ones in locations three five and six and we're going to put in zeros in the other locations yeah does it make sense and the same for S3 and S4 so S3 is one two and six so that's one one and the six is one and then zero in the other locations and there's four is four five and six so that's one and the last three locations and zero in the other all right so that's our vectors okay so that's uh V 1 V 2 V3 and V4 captain all right so now what's so special about these vectors well let's look at the exact cover by three such problem right look at this instance of the create a let's look at what happens when I take a solution so here this is a candidates this is a solution S one and S two together partition the entire universe and let's look at the associated vectors so I see here that every element of the universe appears in exactly one of these two sets right so so every element of the universe must appear on exactly one of these sets which means that when I add up these two vectors together I'm going to get a vector that's 1 in every coordinate and that's just because every element of the universe appears in exactly one of these sets so when I add up the vectors together I get exactly a one in one place and 0 everywhere else so when I add them up I'm going to get a vector v which is just so let me okay let's do it here so V which is just 1 1 1 1 6 times okay and this is going to be my target vector so that's a reduction so you turn every set into a vector vector with zeros and ones and you your target Vector is just going to be a vector which has a one in every coordinate and so now why does this reduction work so you see here that if you have a collection of subsets like V1 and V2 that partition the universe so a solution to the exact cover by three sets problem if you add together the associated vectors you're going to get exactly a one in every coordinate simply because every element of the universe appears in exactly one of the sets so when you add them together you're going to get a one negative chord so that's good on the other hand if you take take a collection of vectors that don't correspond to a solution so let us take for instance B2 V3 and V4 for instance so if I look at V2 plus V3 plus V4 right that's not a solution to my exact cover by three sets problem in particular because the element six appears in all three of these sets so it's not a solution I am not partitioning the universe into these sets 6 appears in all three so in this case V2 plus V3 plus V4 when I look at the entries of V2 plus V3 plus V4 I see the fact that 6 appears in all three of these entries so I'm going to get a 3 in the last coordinate I'm also going to get a 2 in the second last coordinate and some other weird stuff right so I'm not going to get a Target I'm not going to achieve my target sum of the all ones well so the only way for a sub collection of these vectors to add up to the all ones Vector is if every element of the universe appears in exactly one of those sites which is exactly the problem which is specified in this exact color by case that's exactly the problem you want to solve okay so if we turn sets to zero one vectors this way we preserve the solutions to this problem so this is a valid reduction foreign okay so that's good so that's uh already the first part that which is that we've reduced to like a vector version of the problem that we wanted but this is not quite the problem we want because in subset sum we just have a collection of numbers okay these are not vectors but numbers so now I wanted what I want to do is I want to convert these vectors to numbers and uh I don't know so if you think about this problem right so now I have these vectors and I want to turn them into numbers what's is there something that comes to mind so how would you turn these vectors into numbers so I have a list of numbers and I want to turn them into a single number each yeah just throw yes go ahead sum these numbers together so you would say V1 maps to 3. right that's what that's what you would do if you if you sum them together then you're gonna get three for all of them right because all of them are sets of size three so it's not going to work so yes okay so so that's a different idea and that's that's very close to where we want to go so that's so yeah so but just to finish the previous question so uh if you sum them all together you're always going to get three and therefore that's not going to be a very interesting instance so that's a problem with that reduction but the next idea was to use the fact that these are zeros and ones right so kind of just looking at it if you kind of squint at it these look like numbers in binary notation so why not just think of them as numbers in binary notation right because when you sum numbers in binary again you're doing something very similar right you're just adding things together so it seems similar so that's a that's a very good idea and let's try that so that's going to be the number so let's take let's take A1 for instance so let me take A1 to be the vector V1 but in binary notation right so what would be the vector V1 in binary notation now I'm just going to think of it as a a number in binary notation so I'm going to get 0 times 2 to the 0. plus 0 times 2 to the one and I'm just writing out the numbers here so 1 times 2 to the 2 plus 0 times 2 to the 3 plus 1 times 2 to the 4 plus 1 times 2 times 5. okay so I'm just writing down the number in binary notation and this is the number I get which I guess is something four plus I don't know 16 plus 32 so I mean 52 Maybe unless I made a mistake okay so it's going to be some number right and you could do this for all the vectors including the vector v right so the target vector k would be the all ones Vector but in binary notations 1 times 2 to the 0 plus 1 times 2 to the one one times two to the 5 it should be something I don't know 63 I think ok so and you can turn them all into numbers this way and it's this is a very good idea in particular because what happens is that if you take V1 plus V2 right this is a candidate solution before and if you think of them instead as numbers in binary and you add them together you're still going to get the all ones number in binary right because vector addition is the same as integer addition because that's what you do right when you add numbers together in I don't know using our standard algorithm which we learn for decimals but we can also use for binary right if we add these numbers together we add 0 and 1 we get one zero and one we get one so we add them together as numbers we're still going to get the all ones number so that's great so Solutions are still going to map to Solutions just like before yeah unfortunately though you have to be a little bit careful with non-solutions right so if I take a non-solution here V2 V3 and V4 so I erased it here which is a mistake but when I added V2 plus V3 plus V4 before I got a vector with a 3 the last entry and that's what told me that it was not a solution okay but now when I add these numbers in binary things get a little bit more messy right because in binary you don't really have the number three so when you add one plus one plus one you're going to get a one with a carry over one and then that carry is going to affect what happens later and in general it's going to be a mess to analyze okay so it's very it's a very good idea to encode things in binary notation uh it's a very good idea to encode things in binary notation uh I don't know the source of the sound but okay so let me just finish this thought and if it continues look at it so uh it's a very good idea to encode things in binary notation but things which are not solutions to begin with but end up being Solutions simply because of all this carry Mass okay so instead you want to avoid this carry if possible okay and you want the sums of these numbers to kind of reflect what you were doing in the vector world so then is there a kind of a simple fix that is suggested that kind of suggests itself to you if you want to fix this and avoid carries what would you do instead of encoding things in binary notation it's almost there so okay so what we would do is to avoid the carry we don't work in we don't work in binary notation but we work with a higher base yeah so instead of working in binary we could work with base five so now just encode everything in base five okay so now encode everything is base 5 it's not 52 anymore it's some other number right but now the advantage is that every column here has at least four ones right so when you sum the vectors together you're going to get at most of four in each entry and therefore there's never going to be a carry yeah so when you do the algorithm if you're not going to get a one if you're going to get at least two ones in every in some column or your then you're going to get at most four ones and that's going to show up in the sum that you create so when you sum these numbers together so let's say A2 plus A3 plus A4 you're going to get a number which still has a 3 in the last place and then something else the previous position right and the reason for this three in the last place is that 3 is less than 5. 5 that's good so there's not going to be a carry and that's it so that's the idea of the reduction so now in general when you're reducing the M vectors instead to a collection of numbers you want to work in base M plus 1. to ensure that there's no carry and that's the the whole idea of the reduction and in general this number a i is going to be you know the the vector v i but in this base M plus one so if I want to write down the number it look like this so maybe the jth entry of the I times M plus 1 to the power G so that's the numbers that you get and of course K is still the encoding of the vector v which is the all ones Vector in base n plus one yeah yeah and what we've done in this process is we've preserved exactly the space of solutions that we had to begin with so we've reduced exact cover by three sets to subsets okay okay so what we did was we we showed now that the subset some problems NP hired but you see here that the numbers that you get in the reduction right these numbers A1 through a n they're not small numbers they are exponentially large numbers they're very very big numbers but nevertheless you can write them down efficiently because to write down an exponentially large number requires only polynominally many bits right so as long as you're encoding them in binary notation you can write them down efficiently okay you encourage another binary or some other notation we write the more efficiently you can't encode them in unary notation so what we've shown is there's a substitute some problem in binary notation is anti-hi and naps the knapsack problem as a result in binary notation is MPI okay so you can see that the the representations of these numbers are kind of crucial to these reductions what we also can achieve fairly easily observe is that the knapsack problem which is this more General problem in the unary case is actually easy ok so I'm so in the unary case this is actually easy so there's a reason why we have to get these exponentially large numbers in this reduction because in the unitary case the problem actually has an efficient algorithm so let me just quickly describe this algorithm and we'll go on a break uh so what's the algorithm for Unity knapsack so it's a very simple dynamic programming strategy right and so what we're going to do is we're just going to build up a table so the setup again is that we have these n items 1 through n with weights and values and you have a budget and you want to kind of find the maximum value that you can achieve subject to this budget right and so what we're going to do to solve this problem is that we're going to create this big table and this table is going to be indexed by ah the I so the columns are going to be indexed by the items so you have n items so it will be n columns yeah and the rows are going to be indexed by the possible weights of your knapsack yeah so what are the possible weights of your knapsack so you have a weight budget of B so the weights are all possible integers from 1 through b and here we are using the fact that b is small because the num the inputs are given in unary so this is going to be an efficient algorithm and so what's this table going to do well in the in the ith uh in the ith column and corresponding to some weight w here so some entry here what we are trying to do is we are trying to answer the following question suppose I am allowed to choose only from items one through I that's just the first I items and suppose my weight constraint was not B but some smaller number w suppose I'm allowed to choose only from the first I items but I have a some other weight constraint what's the maximum value I could derive under this constraint right so this entry is the maximum value that I could derive by just picking from the first I items under a stronger weight constraint of being less than equal to w and we're going to fill up this table now so in general when we get to the last entry of this table the bottom entry that's going to be the solution to the problem that we started with so that's a budget constraint of B and we have all the N items under consideration okay so that's going to be the final answer that we care about but what we're going to do so it's very easy now to kind of fill up the entries of the stable column by column okay so we fill up the First Column that's going to be very simple the second column third column so on but in general imagine that we are filling we fill the ith column and we are going to the I plus First Column right yeah and so we have a kind of a nice recursive formula for the entry in a in the I plus First Column in terms of the entries in the ith column what's this recursive formula saying so in the I plus First Column I am allowed to pick from items one through I Plus 1. so I could either pick item I plus 1 or not pick up the I plus one so I have two choices I could either ignore item I plus one or decide to put it
