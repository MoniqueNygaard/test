sat to two SATs this way and if we could it would be great because we actually know how to solve two sat in polynomial time and we would have shown that P equals NP so unfortunately though this argument stops at three sat and there's a very good reason for it because two Sat happens to be in polynomial so we'll see that after the break so let's stop and come back in 15 minutes okay foreign foreign so let's get started again uh yeah so welcome back um okay so uh I guess in the first part of this lecture we showed that uh three sat is NP complete and as a result four sat five set and all sets of higher widths already complete and in the second part of this lecture we are going to show that two Sat in contrast to all these other variants of sand two Sat actually has a polynomial time algorithm okay so it's very unlikely to be NP complete and curiously the idea for this algorithm is going to sort of be the same idea that we used to this reduction from side to three side so the idea behind this reduction was to introduce a new variable and we use that new variable to sort of simplify the formula in the sense that we reduce the width of the SAT formula that we had yeah but now to come up with a site algorithm you're kind of going to use the same idea but in Reverse okay in Reverse what we're going to do is we're going to start with the CNF formula okay may have small width may not yeah and what we're going to do is we're going to use the same idea to eliminate a variable so here we introduced a new variable in the going in the forward direction we're going to use the same idea in Reverse to eliminate a variable so we're going to end up with a formula of one variable less and then we're going to repeat this idea to reduce the number of variables iteratively until we're down to no variables at all and at that point sat is really easy okay so that's the idea behind the algorithm and in general there's an algorithm for General CNF sat okay so I'll just describe an algorithm for you now it's going to work on any CNF sat instance unfortunately on General instance is this algorithm runs in exponential time but for two CNF sat it actually runs in polynomial because two Cena formulas this is a polynomial okay so what's the idea of the algorithm again it's the same idea but applied in Reverse so what you do is that you take some variable so this y1 is just some variable appearing in our formula and every time you have a pair of Clauses like this yeah you replace so you have one clause in which y1 appears positively and another clause in which y1 appears negatively so you replace these two Clauses by this kind of big Clause here okay and the same kind of argument that we did before we're going to see it again but the same kind of argument that we did before we argued that oh if we had a satisfying assignment for this formula the satisfying assignment was either satisfy this part of the clause or this part of this clause and when we put these two Clauses together therefore the assignment also satisfies this big clause okay so we sort of preserve satisfiability coming in the reverse Direction so we're going to do exactly this but it's a little bit more complicated because the variable y1 here it was a new variable we were introducing so it only appeared in these two clauses but if y1 was just some variable of the formula we have no control over y one then y1 could appear in a bunch of Clauses okay and we have to do this kind of operation for every pair of Clauses like this so let me describe now the operation in a little bit more detail so it's called resolution so resolution so now we are resolving on some variable okay and in the slide it's called X so let me change also here let me change y1 to X okay so what we're going to do is we're going to take this variable X and what this procedure is trying to do is is trying to get rid of x from the formula so we now will have a new formula that does not contain X at all okay and so how do we do this so we take all the Clauses in which X appears positively right so we take all clauses that look like this maybe okay and in all of these Clauses there's a positive occurrence of X and then there's the rest of the clause and we're calling this P1 P2 Etc okay so P1 P2 etcetera on the first row so those are all the Clauses in which X appears positively X appears as X so all those Clauses look like this X or P 1 X or P2 Etc yeah and then we take all the Clauses in which X appears negatively so X appears as not X and now there's the rest of this Clause so it might be p q 1 Q 2 etcetera okay and then there are a bunch of Clauses in which X appear X does not appear at all okay and that's what we're calling r on the slide so we're not going to worry about R because we're going to leave it the same okay we're not going to touch it so R stays the same and now we do this resolution procedure that I just talked about for each of these pairs of Clauses in which X appears positively and negatively so I take every pair of Clauses where X appears positively and X appears negatively and I do this operation I remove X and I or the rest of the Clauses together okay so so I have X and not X they kind of cancel each other out so they go away and then what you're left with is the rest of I guess in this case it's P1 or q1 and now you don't do this just for one pair of Clauses but you do this for every pair of Clauses where X appears positively in one and negatively in the other okay so you look at every Pi you know every one of P one to p k those are the ones in which X appears positively and every one of q1 to Q L and you do this resolution procedure okay so you kind of resolve them together to get a bigger clause and a bunch of bigger Clauses perhaps but the the entire process has the uh kind of effect that you get rid of X so now you see that you get a big formula at the bottom here of the slide yeah but the new formula does not contain the variable X at all okay so you kind of resolved out X okay you kind of canceled X from all the uh Clauses in which X appeared so you start with the formula f and you end up with a formula let's call it resolve f x which is this formula here does it make sense there's a process what the thing is doing yeah okay so this process okay so it seems like it could blow up the size of the formula quite a bit right you'll get a bunch of new Clauses but the important thing is that X is no longer present okay so what we are going to first argue is that f is inside if and only if this is inside right so the original formula was satisfiable if and only if the new formula is satisfiable and now this will give us the confidence that we can repeat this process so we preserve the answer so now we repeat the process and get rid of a new variable and then a new variable a new variable we keep doing this until there are no variables remaining and that gives us kind of an algorithm for satisfiability okay so that's a basic idea so let's just quickly argue this so the argument is not hard it's exactly the argument that we did already in the previous part of the lecture it's just a little bit more souped up because you have all these a bunch of Clauses involving the variable X so let's see so again so let's say that the formula involved the variables X1 to X N and maybe also the variable X okay yeah let's say you had a satisfying assignment for a so how would you get a satisfying assignment for the resolved formula right so you have n plus one variables but the result formula has only n of them so you just keep the values for the N variables and this gives you a satisfying assignment for this resolved formula and the argument is exactly the same that we did before we said oh if you have a satisfying assignment for these clauses the satisfying assignment must set either X to 1 in which case it sets not X to 0 and hence it has to satisfy q1 or the satisfying assignment since X to 0 in which case it has to satisfy P1 and therefore it must satisfy P1 or q1 so it's it's the same argument that we did already for uh the reduction suicide to three side and in the same way it satisfies P2 or q1 and P5 or Q7 etc etc so all those Clauses that we introduced so the same assignment satisfies in fact all the Clauses of the new formula does that make sense okay so we also have to do an argument in the other direction right so if X1 to x n is a satisfying assignment for the result formula now we need to manufacture a satisfying assignment for the new formula so we keep the values of X1 to extend the same but we have to set the value of the variable X in some suitable way and this was also uh a part a feature of the previous reduction so there we set the variable Y in a suitable way and now okay the Y is X but we have to set the variable X in a suitable way so how do we set the variable X so we need a simple observation in order to set the variable X so the observation so let me write it let me write it down here so if I write here is everybody able to see it okay it seems like it's on the line of sight so uh the observation is that when you have a satisfying assignment for this resolved formula right a satisfying assembly so this resolved formula so let's call it X1 to X N because those are variables in the result formula the satisfying assignment is much either satisfy all the P parts of the Clauses P1 to p k or the satisfying assignment must satisfy all the Q parts of the clauses q1 to qn okay so it must satisfy either all the P parts or all the Q parts and this is the only way to do it yeah yeah and this this requires kind of a moment of thought it's not immediately obvious let's imagine that the satisfying assignment did not satisfy I don't know P5 and let's say it did not satisfy I don't know q20 so if it did not satisfy P5 and q20 you can look at the Clause P5 or q20 in the result formula and the satisfying assignment would not satisfy either P5 or q20 so it would not be a satisfying assignment that's a problem so the only way that it satisfies all these new Clauses that we've introduced a bunch of new Clauses K times L many of them is to either satisfy all of P1 to p k or satisfy all of q1 to ql okay so it's got to choose it's got to choose either that I satisfy this or this of course you could do both but it has to choose at least one of these sides to satisfy complete and that gives us an idea for how to set X okay so we set X to 0 or 1 depending on which of these cases we are in all right so now I want you to think about it just think about it for a couple of minutes so how would we set X to 0 or 1 depending on these two cases just feel free to discuss among yourself and give me an answer in a couple of minutes maybe so how would you say X okay this so does somebody want to kind of take a shot at the answer yes yes right so so you're saying okay if if you're in this case if X1 to X N satisfy all of q1 to Q L then that means in each of these kinds of clauses this part is already satisfied so we don't we don't need to worry about this part so we can set X to Zero I'm sorry we can set X to 1 to satisfy all these classes so we set X to 1 if X1 to x n satisfies the Q part of all the Clauses so q q 1 to ql and we set it to zero in the other case right if X1 to x n satisfies P1 to p k yep it's absolutely right and yeah that's the that's the proof right so so we showed that we eliminated a variable X right we threw away x x is no longer present in this giant thing but nevertheless we have preserved the answer to the satisfiability question the new formula is satisfiable if and only if the old formula of satisfied and we can repeat this process we can eliminate more variables and that sort of gives us an algorithm okay so this is the algorithm it's called the Davis Putnam procedure and the idea is the following that we keep eliminating variables okay and we keep eliminating variables if until as long as we have Clauses from which we can eliminate variables right so if you have no Clauses whatsoever then we'll be in trouble we cannot eliminate any more variables but if we have no clauses well then if we have no Clauses then there's nothing to do there's nothing to satisfy right so then the problem is easy to solve you just say yes it's satisfiable there are no Clauses to satisfy so that's fine so we as long as there are clusters satisfied we keep repeating this procedure but if at some point of time we end up with an empty clause if we end up in an empty clause the only way to satisfy a clause is to set at least one of its literals to true and if you end up with an empty clause that's a clause that cannot be satisfied okay so if you end up in an empty Clause at any point of time that means that we end up with a clause that can never be satisfied so we give up we say that the formula is not satisfiable and that's the whole process so we keep eliminating variables as far as we can and now if we if at any point of time we run out of clauses then we say that the formula is trivially satisfiable because there's nothing to satisfy if at some point of time we end up with an empty Clause he said there's no way to satisfy this Clause the formula is unsatisfied and we give up the only thing to kind of verify is that oh how do we end up with an empty Clause how do we end up with empty clauses I mean how to end up in an empty formula we can end up with empty Clauses because we're eliminating variables so that makes sense but how would you ever end up with an empty formula it seems like like you're introducing lots of new Clauses all the time how can we end up with an empty formula well the reason for it is that sometimes you might resolve things and you might end up with trivial Clauses so let's take an example here so imagine that we had this thing and now instead of having X3 or X4 or X5 here let me change this X3 to a naught 2 and X2 okay let's imagine that we had this X2 here and now when we resolve these two we would get an X2 and a not X I'm sorry a not x 2 and an X2 right so you would get a clause that both contains a variable and it's negated form okay and this kind of clause is stupid right it's always satisfied right it doesn't matter if you said X2 to 0 or 1 it would always be satisfied so we can just throw away Clauses of this kind yeah so though it seems like in the process of resolution we're creating lots of new clauses and it seems like we're creating lots of new Clauses any sort of clause that contains a variable and its negative form can be thrown away and this way you can throw away lots of these Clauses and it's possible that you end up with simply an empty formula without any clauses and if you end up in that case you sort of give up I mean you sort of stop and say the formula is satisfiable yeah and that's the whole process that's the whole algorithm so keep repeating this procedure eliminate variables when you cannot eliminate variables any further then the answer is fairly clear does it make sense okay cool uh so this is an algorithm for satisfiability on CNF formulas in general okay okay so this is for uh General sat and in general this indeed does take exponential time and this process where you introduce lots of new Clauses it might actually blow up the size of your formula you might have to repeat this process a bunch of times and your formula keeps growing and growing and growing it becomes really big even if you start with a small formula in the beginning so this process is not great for General CNF formulas but let's argue that for two CNF formulas so if you start with the two CNF formula then this process is actually a polynomial time algorithm so what would happen if you resolved a two CNF formula now what what kind of Clauses do you get when you resolve two Clauses of width two yeah so if you have a two CNF formula so you might have maybe uh X or maybe not x one and not X or maybe x three right you could resolve these two Clauses and when you resolve them the X and the not X would go away and you'd end up which is not x one or X Type okay and so the observation is that when you apply this this procedure to a two CNF formula you also again get a two CNF formula so things sort of stay in control you don't make a so if you applied it to a three CNF formula you would get a 4C and a formula and a five c and a formula and so on right but if you apply it to a two CNF formula you stay at two CNF formula and this is kind of going to be the the linchpin of the analysis of the running time so let's analyze the running time of this algorithm on a two CNF formula so let's start with the two CNF formula maybe on N variables and let's try to analyze what happens to a running time of this procedure so what do I need to do I start with two scene of formula n variables so I'm going to eliminate some variable X right I'm going to have to find all the Clauses in which X appears positively right so I'm going to have to find all such Clauses like this so how many such Clauses can I have so K is the number on the slide so let's call it K how large can K be well if x appears positively so X is going to be there then there's going to be one other thing that one other thing could be one of the other variables occurring positively or one of the other variables occurring negatively right so there are two n possibilities for what the other thing could be they could also be the possibility that there's nothing else it's just X in which case you'd have one more yeah so in any case it's a it's an O of n number of possibilities so the O of n positive possible Clauses in which X appears positively and in a similar way they're going to be o of n possible Clauses in which X appears negatively okay and now when we do the resolution we have to look at all pairs of these things and we have to resolve and we have taken all pairs of these things and you have to resolve and that's going to take K times L which is O of N squared time so every time they resolve we're going to spend o of n Square time okay and that's going to reduce the number of variables by one but we still have a two CNF formula at the end so we can apply the same argument again and then again we take o of n minus 1 squared time to resolve the second time and then o of n minus 2 square time to resolve the third time and so on so you repeat this whole process n times to get an O of n cubed time algorithm okay so every time you resolve because you always have a two C and F Formula the time for resolution always takes o of n Square time okay resolve and you get the new formula which is again a two C and F you resolve again then a two CNF etcetera so and each of those iterations Takes Over N Square time so in the worst case this algorithm is going to take off in Cube time it makes sense the running time okay so that is the important part in this that the width of the CNF does not blow up which is why the same analysis holds for every iteration of this algorithm okay and that's it so that's a polynomial time algorithm of course we argued with the pseudocode but we know by the polynomial Church during thesis that it's also going to hold for Turing machines okay and that gives us sort of a very nice polynomial time algorithm to check if a two CNF formula is satisfied so two side actually is a polynomial time problem okay all right so any questions about this questions comments okay so I thought I'd tell you about one more algorithm for the fact that two set is on polynomial time so the the algorithm that we just saw was sort of very logical it applied